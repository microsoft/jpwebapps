<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Web Developer Platform WebApps Team Blog</title>
  
  <subtitle>日本マイクロソフトの Azure Bot Service / Internet Information Services (IIS) に関するサポート情報のブログです。</subtitle>
  <link href="https://microsoft.github.io/jpwebapps/atom.xml" rel="self"/>
  
  <link href="https://microsoft.github.io/jpwebapps/"/>
  <updated>2025-08-19T02:33:38.397Z</updated>
  <id>https://microsoft.github.io/jpwebapps/</id>
  
  <author>
    <name>Web Developer Platform WebApps Japan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IIS の基本的な情報の自動採取について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/iis-log-auto-collection/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/iis-log-auto-collection/</id>
    <published>2022-05-15T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.397Z</updated>
    
    <content type="html"><![CDATA[<p>IIS サポートチームの大嶋です。<br>本稿では、IIS の事象発生後にまず初期調査のための情報採取の際に利用できる自動採取ツールをご紹介します。</p><p>なお、本ツールは OSS となり、我々の技術サポートでサポートするツールではございません。<br>もしツールでの採取に不明点・懸念点や上手く取得できない等ありましたら、まずは手動で以下の採取をご検討下さい。</p><p><a href="https://microsoft.github.io/jpwebapps/web-apps/LogCollection1/">IIS の調査に必要な基本的なログ情報について</a></p><hr><h2 id="採取方法について"><a href="#採取方法について" class="headerlink" title="採取方法について"></a>採取方法について</h2><ol start="0"><li><p>事象を再現します。</p></li><li><p>上記再現後、 IIS 側のサーバーにて、以下より LogCatcher (.zip) をダウンロードします。</p><p><a href="https://github.com/crnegule/LogCatcher/releases/latest">https://github.com/crnegule/LogCatcher/releases/latest</a></p></li><li><p>ダウンロード後、必ず解凍前に LogCatcherV3.3.zip を右クリックし、[プロパティ] を開きます。</p></li><li><p>プロパティ [全般] タブ下部の [セキュリティ] 欄の [ブロックの解除] (Unblock) をチェックをし、[OK] または [適用] します。</p></li></ol><p><img src="/jpwebapps/web-apps/iis-log-auto-collection/logcatcher-property.png" alt="LogCatcherV3 のプロパティ"></p><p><img src="/jpwebapps/web-apps/iis-log-auto-collection/unblock.png" alt="ブロックの解除"><br>(チェック後の UI イメージ)</p><ol><li><p>上記のブロックの解除のチェックを設定後、.zip ファイルを展開します。</p></li><li><p>Power Shell を [管理者として実行] より、管理者権限で開き、該当の LogCatcherV3 のフォルダに cd コマンドで移動します。<br>(temp フォルダ配下に配置した場合の例 : cd C:\temp\LogCatcherV2.2)</p></li><li><p>cd コマンドにて LogCatcherV3 のフォルダ内に移動後、以下のコマンドでログ採取ツールの UI を起動します。</p></li></ol><p>  .\LogCatcher.ps1</p><ol start="7"><li><p>下部より、事象が発生した採取対象となる IIS のサイト名 (name) を一覧より確認し、id の部分 (サイト ID) を把握します。(以下は Default Web Site だった場合のイメージ例です。)</p><p><img src="/jpwebapps/web-apps/iis-log-auto-collection/logcatcher-list.png" alt="サイト一覧"></p></li><li><p>[Logs Age] にて、上述の再現させた日にちを最低限含むように何日前までのログを含むか設定します。加えて、[Site IDs] の欄に、上記で控えたサイト ID を記載します。<br>※ なお上部の手順より先ほど直近で再現を実施した場合には [Logs Age] は 3 で一旦設定ください。</p><p><img src="/jpwebapps/web-apps/iis-log-auto-collection/select-ages.png" alt="Age と Site ID の指定例"></p></li><li><p>[GENERATE ZIP] を押し、ログ採取を開始します。暫く時間がかかりますので、UI に触らずに放置しておきます。途中で完了前に UI に触ってしまうと停止する恐れがあります。<br>完了後、以下のような Zip 生成が完了した緑色の欄が表示されます。該当箇所に採取された zip ファイルのパスが表示されてますので、こちらの .zip ファイルをご提供下さい。</p></li></ol><p><img src="/jpwebapps/web-apps/iis-log-auto-collection/logcatcher-success.png" alt="採取成功"></p><p>今回は以上です。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IIS サポートチームの大嶋です。&lt;br&gt;本稿では、IIS の事象発生後にまず初期調査のための情報採取の際に利用できる自動採取ツールをご紹介します。&lt;/p&gt;
&lt;p&gt;なお、本ツールは OSS となり、我々の技術サポートでサポートするツールではございません。&lt;br&gt;もしツールで</summary>
      
    
    
    
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
  </entry>
  
  <entry>
    <title>Azure Web Apps の .NET Profiler の取得時間を変更する方法について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/webapps-dotnet-profiler/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/webapps-dotnet-profiler/</id>
    <published>2022-01-06T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.399Z</updated>
    
    <content type="html"><![CDATA[<p>IIS / ASP.NET サポートチームの大嶋です。</p><p>本稿では、先日投稿した <a href="https://microsoft.github.io/jpwebapps/web-apps/webapps-diagnostic-tools/#3-Azure-Web-Apps-%E3%81%A7-NET-%E3%81%AE-Profiler-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9-ETW-%E3%81%A3%E3%81%A6%E5%8F%96%E3%82%8C%E3%82%8B%E3%81%AE%EF%BC%9F">Azure Web Apps の .NET の Profiler トレース (ETW)</a> の取得時間を既定値の 60 秒から変更して取得する方法について、ご紹介します。</p><p>.NET Profiler を取得したい再現リクエストの秒数が 60 秒より短かったり、逆に 60 秒より長いことが見込まれたりと、取得秒数を既定値から変更したい場面はあるかと思います。</p><p>そのようなときは、具体的には、以下 Azure Portal 上の操作で .NET の Profiler トレース (ETW) を取得の目安時間を変更した上で採取が可能です。なお、意図的に事象が再現できる手順が確立出来ていることが前提です。</p><hr><h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><ol><li>App Service Plan が Standard 以上の必要があるため、該当の Azure App Service のリソースの [スケールアップ] ブレードから S1 プランなど Standard 以上にスケールアップします。</li><li>常時接続機能が有効である必要があるため、[構成] ブレードの [全般設定] タブから [常時接続] を [オン] に変更します。</li></ol><h2 id="取得時間の変更"><a href="#取得時間の変更" class="headerlink" title="取得時間の変更"></a>取得時間の変更</h2><p>※ もし、既定値の 60 秒から変更する必要がない場合はこの手順は不要です。</p><ol><li>[構成] ブレードの [アプリケーション設定] タブの [+ 新しいアプリケーション設定] を押します。</li><li>名前 (キー) を “IIS_PROFILING_TIMEOUT_IN_SECONDS” に、値を “.NET Profler を取得したい秒数” に設定し、[OK] を押します。<br>なお、最大値は 899 秒までですので、必ず 900 以上に設定しないようにご注意ください。</li><li>上部の [保存] ボタンを押し、アプリケーション設定の変更を保存します。</li></ol><p><img src="/jpwebapps/web-apps/webapps-dotnet-profiler/webapps-dotnet-profiler-profiling-timeout.png" alt="取得時間のアプリケーション設定"></p><p>準備が整ったので、以下の再現時の取得手順に進みます。</p><h2 id="再現時の採取手順"><a href="#再現時の採取手順" class="headerlink" title="再現時の採取手順"></a>再現時の採取手順</h2><ol><li>Azure Portal 上で Azure Web Apps のリソースページ にて [問題の診断と解決] ブレードを開きます。</li><li>検索欄から [Collect .NET Profiler Trace] を開きます。</li></ol><p><img src="/jpwebapps/web-apps/webapps-dotnet-profiler/dotnet-profiler1.png" alt="Collect .NET Profiler パネルの検索"></p><ol start="3"><li>取得する Instance(s) のチェックボックスにチェックします。</li><li>[Collect Profiler Trace] ボタンを押します。</li><li>Step 1 が完了し下記の画面 (Step 2) になるのを待ちます。</li><li>Step 2 になったらトレースが開始した状態のため、すぐに再現リクエストを行います。<br>(自動停止の Step 3 の停止に行くまでの間に必ず再現を行います)</li></ol><p><img src="/jpwebapps/web-apps/webapps-dotnet-profiler/dotnet-profiler2.png" alt="Collect a Profiler Trace の取得開始"></p><ol start="7"><li>完了後、.NET Profiler のトレースを含む .zip のリンクをクリックすることで、.zip 形式のプロファイラーのファイルをダウンロード可能です。</li></ol><p>今回は以上です。 それでは、また次回！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IIS / ASP.NET サポートチームの大嶋です。&lt;/p&gt;
&lt;p&gt;本稿では、先日投稿した &lt;a href=&quot;https://microsoft.github.io/jpwebapps/web-apps/webapps-diagnostic-tools/#3-Azure-</summary>
      
    
    
    
    
    <category term="Azure App Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-App-Service/"/>
    
    <category term="C#" scheme="https://microsoft.github.io/jpwebapps/tags/C/"/>
    
    <category term="IIS" scheme="https://microsoft.github.io/jpwebapps/tags/IIS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Web Apps でオンプレ IIS と同じような情報は取れるのか？</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/webapps-diagnostic-tools/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/webapps-diagnostic-tools/</id>
    <published>2021-12-22T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.398Z</updated>
    
    <content type="html"><![CDATA[<p>本記事は <a href="https://qiita.com/advent-calendar/2021/microsoft-azure-tech">Azure Tech Advent Calendar 2021 23 日目</a> の記事です。</p><hr><p>Azure Web Apps でもオンプレ IIS の時に取っていた情報が同様に取れるのか…？<br>-&gt; はい、実は色々取れるものもあります。例えば…<br>という Blog です。</p><p>IIS サポートチームの大嶋です。</p><p>我々のチームでは普段オンプレミス製品である IIS や ASP.NET をサポートしてます。<br>ですが、今回は Azure Tech の Advent Calendar ということで、せっかくなので IIS とも親和性がある Azure PaaS の App Service ファミリーの Azure Web Apps (Windows) に関して、取得可能な情報を一部ですがご紹介しようと思います。</p><p>ちなみに、本稿では、具体的に有効な場面や情報の詳細等には踏み込みません。こういったものも Azure Web Apps でも取れるんだと思って頂ければと。</p><p>具体的に、本稿では以下をご紹介します。</p><ul><li>アプリケーション イベントログ</li><li>ネットワーク トレース</li><li>.NET Profiler トレース (ETW)</li><li>メモリ ダンプ</li></ul><p>皆様のトラブルシューティング時の今後の材料の 1 つとして、お力添えになればと思います。それでは、早速、具体的な手順の紹介に進みましょう。</p><hr><h2 id="1-Azure-Web-Apps-でアプリケーション-イベントログって見れるの？"><a href="#1-Azure-Web-Apps-でアプリケーション-イベントログって見れるの？" class="headerlink" title="1. Azure Web Apps でアプリケーション イベントログって見れるの？"></a>1. Azure Web Apps でアプリケーション イベントログって見れるの？</h2><p>見れます。アプリケーション イベントログは <a href="https://microsoft.github.io/jpwebapps/web-apps/LogCollection1/">IIS の調査に必要な基本的な情報</a> の 1 つです。<br>以下の手順で Azure Portal 上でアプリケーション イベントログを確認することが可能です。</p><ol><li>Azure Portal 上で Azure Web Apps のリソースページ にて [問題の診断と解決] ブレードを開く</li><li>検索欄から [Application Event Logs] を開く</li><li>アプリケーション イベントログを閲覧する</li></ol><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/eventlog1.png" alt="Application Event Logs パネルの検索"></p><hr><h2 id="2-Azure-Web-Apps-でネットワーク-トレースって取れるの？"><a href="#2-Azure-Web-Apps-でネットワーク-トレースって取れるの？" class="headerlink" title="2. Azure Web Apps でネットワーク トレースって取れるの？"></a>2. Azure Web Apps でネットワーク トレースって取れるの？</h2><p>取れます。以下手順で Azure Portal 上の操作でネットワーク トレースを取得可能です。ネットワークトレースも <a href="https://microsoft.github.io/jpwebapps/web-apps/LogCollection2/#2-%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9">IIS の通信系の調査</a> に活用する可能性のある情報です。</p><p>ただし、こちらは意図的に事象が再現できる手順が確立出来ていることが前提です。</p><ol><li>Azure Portal 上で Azure Web Apps のリソースページ にて [問題の診断と解決] ブレードを開く</li><li>検索欄から [Collect Network Trace] を開く</li></ol><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/network-trace.png" alt="Collect Network Trace パネルの検索"></p><ol start="3"><li>取得したい秒数を選択し、[Collect Network Trace] ボタンを押す</li><li>再現リクエストを実施する</li><li>取得が完了すると zip ファイルがクリック可能になるのでクリックしダウンロードする</li><li>ダウンロードした zip ファイルをローカル環境で解凍し、解凍後の .cap ファイルをネットワークトレースを閲覧する Wireshark 等のツールで確認する</li></ol><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/network-trace2.png" alt="Collect a Network Trace の取得"></p><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/network-trace3.png" alt="トレース取得後のイメージ"></p><hr><h2 id="3-Azure-Web-Apps-で-NET-の-Profiler-トレース-ETW-って取れるの？"><a href="#3-Azure-Web-Apps-で-NET-の-Profiler-トレース-ETW-って取れるの？" class="headerlink" title="3. Azure Web Apps で .NET の Profiler トレース (ETW) って取れるの？"></a>3. Azure Web Apps で .NET の Profiler トレース (ETW) って取れるの？</h2><p>取れます。以下手順で Azure Portal 上の操作で <a href="https://microsoft.github.io/jpwebapps/web-apps/LogCollection3/">PerfView 等で取得・閲覧可能</a> な .NET の Profiler トレース (ETW) を取得可能です。</p><p>ただし、意図的に事象が再現できる手順が確立出来ていることが前提です。<br>加えて、事前準備が必要です。</p><p>&lt;事前準備&gt;</p><ol><li>App Service Plan が Standard 以上の必要があるため、[スケールアップ] ブレードから S1 プランなど Standard 以上にスケールアップする</li><li>常時接続機能が有効である必要があるため、[構成] ブレードの [全般設定] タブから [常時接続] を [オン] に変更する</li></ol><p>準備が整ったので、以下の手順に進みます。</p><p>&lt;再現時の採取手順&gt;<br>3. Azure Portal 上で Azure Web Apps のリソースページ にて [問題の診断と解決] ブレードを開く<br>4. 検索欄から [Collect .NET Profiler Trace] を開く</p><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/dotnet-profiler1.png" alt="Collect .NET Profiler パネルの検索"></p><ol start="5"><li>取得する Instance(s) のチェックボックスにチェックする</li><li>[Collect Profiler Trace] ボタンを押す</li><li>Step 1 が完了し下記の画面 (Step 2) になるのを待つ</li><li>Step 2 になったらトレースが開始した状態のため、すぐに再現リクエストを行う<br>(60 秒間で Profiler が自動停止するので、Step 3 の停止に行くまでの 60 秒間以内に再現を行います)</li></ol><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/dotnet-profiler2.png" alt="Collect a Profiler Trace の取得開始"></p><ol start="9"><li>.NET Profiler のトレースを含む .zip 形式のファイルがダウンロードできるようになるので、zip ファイルのリンクをクリックしダウンロードする</li></ol><hr><h2 id="4-Azure-Web-Apps-で-メモリダンプ-って取れるの？"><a href="#4-Azure-Web-Apps-で-メモリダンプ-って取れるの？" class="headerlink" title="4. Azure Web Apps で メモリダンプ って取れるの？"></a>4. Azure Web Apps で メモリダンプ って取れるの？</h2><p>取れます。以下の手順で WinDbg 等でも閲覧可能なメモリダンプを取得可能です。</p><p>ただし、意図的に事象が再現できる手順が確立出来ていることが前提です。<br>加えて、事前準備が必要です。</p><p>&lt;事前準備&gt;</p><ol><li>App Service Plan が Basic 以上の必要があるため、[スケールアップ] ブレードから B1 プランなど Basic 以上にスケールアップする</li><li>常時接続機能が有効である必要があるため、[構成] ブレードの [全般設定] タブから [常時接続] を [オン] に変更する</li></ol><p>&lt;再現時の採取手順&gt;<br>3. Azure Portal 上で Azure Web Apps のリソースページ にて [問題の診断と解決] ブレードを開く<br>4. 検索欄から [Collect Memory Dump] を開く</p><p><img src="/jpwebapps/web-apps/webapps-diagnostic-tools/memory-dump1.png" alt="Collect Memory Dump パネルの検索"></p><ol start="5"><li>新規作成もしくは既存の [Storage account] を選択する</li><li>取得する Instance(s) のチェックボックスにチェックする</li><li>[Collect Memory Dump] ボタンを押す</li><li>ダンプ取得が完了次第、.dmp ファイルが表示されるので、そのリンクからダンプファイルをダウンロードする</li></ol><hr><h2 id="まとめと留意事項"><a href="#まとめと留意事項" class="headerlink" title="まとめと留意事項"></a>まとめと留意事項</h2><p>実は [問題の診断と解決] ブレードは他にも様々な充実した機能が複数ございます。<br>事象や状況に応じて、ぜひご活用いただければと思います。</p><p>なお、上記で紹介した後半 3 つの情報は特定の再現手順が確立できていることが前提です。<br>また、適切な状況で適切な再現タイミングで取得できないと意味をなさない情報です。</p><p>加えて、お客様側での各取得した情報の解析の敷居や難易度も高いことが想定されます。もし解析できたとしても大量の時間がかかる可能性があるため、いわば最終手段の 1 つのようなものです。一概にトラブルシューティングと一括りにしてウェイトが重い情報を闇雲に取得することはおすすめできません。</p><p>じゃあどうすればいいのか。そのために、実は Azure Web Apps にはそのような情報を取らないでも、事象の把握や問題の切り分け、事象によっては原因特定も可能であるツールがいくつも用意されております。</p><p>ちょうど、本アドベントカレンダーの前半でもその一部が紹介されていたので、リンクを載せておきますのでぜひこちらや、公式の情報が知りたい方は App Service の Docs を一読ください！</p><p>本 Advent Calendar 11 日目で紹介されていた <a href="https://qiita.com/mym/items/dcf1114d2ea8b60c6132">App Service で発生した事象を 問題の診断と解決 で確認してみよう</a> </p><p>まずはどういった事象なのかどういうときに発生するのか等を正確に把握したうえで、ぜひ活用してみてください。</p><hr><p>ちなみに、では普段我々のチームでは IIS 以外ではどういう製品を担当しているの？Azure 製品も関わる機会はあるの？という方はぜひ以下のチーム紹介の Blog も一読頂ければと思います！</p><p><a href="https://microsoft.github.io/jpwebapps/general/career1-dsi-technologies/"><Career>&lt;第一弾&gt; Developer Support Internet (DSI) ってどのような製品の技術サポートをしているの？</a></p><p>では、本日のアドベントカレンダーのブログはこんなところで。<br>最近は急な気温の変化もありますのでお身体には気を付けて、良いクリスマスや年末年始をお過ごしください！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2021/microsoft-azure-tech&quot;&gt;Azure Tech Advent Calendar 2021 23 日目&lt;/a&gt; の記事です。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A</summary>
      
    
    
    
    
    <category term="Azure App Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-App-Service/"/>
    
    <category term="C#" scheme="https://microsoft.github.io/jpwebapps/tags/C/"/>
    
    <category term="IIS" scheme="https://microsoft.github.io/jpwebapps/tags/IIS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Web PubSub サービスの利用</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/</id>
    <published>2021-12-19T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.375Z</updated>
    
    <content type="html"><![CDATA[<p>＊本記事は <a href="https://qiita.com/advent-calendar/2021/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2021</a> の 20 日目の記事になります。</p><p>皆さんこんにちは。Developer Support Internet チームの伊藤です。今回の記事では、2021 年 11 月に正式にリリースされた、Azure Web PubSub Service についてご紹介します。少しでもこれから初めて Azure Web PubSub Service に触るという方や、Azure Web PubSub Service の使用を検討してるという方々の参考になればと嬉しいです！</p><h1 id="Azure-Web-PubSub-Service-とは"><a href="#Azure-Web-PubSub-Service-とは" class="headerlink" title="Azure Web PubSub Service とは"></a>Azure Web PubSub Service とは</h1><p>Azure Web PubSub Service とはパブリッシュ-サブスクライブ パターンを利用して、リアルタイムに双方向通信を実現するメッセージング サービスです。(以降、この記事では適宜 PubSub と略します。)<br>例えば、複数人でのチャット サービスや地図アプリでの現在地の表示、複数の IoT デバイスとの情報のやり取り等では、高いリアルタイム性を求められますが、そういったケースでは PubSub の使用を検討できます。</p><p>その他の概要やユースケースは<a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/overview">こちらの公開情報 (Azure Web PubSub サービスとは)</a> にも纏められてます。</p><h1 id="Azure-SignalR-との差異"><a href="#Azure-SignalR-との差異" class="headerlink" title="Azure SignalR との差異"></a>Azure SignalR との差異</h1><p>双方向通信を使用する Azure 製品として、現状 <a href="https://docs.microsoft.com/ja-jp/azure/azure-signalr/signalr-overview">Azure SignalR</a> があります。ただし、Azure SignalR と PubSub はどちらが上位互換であるというものではなく、それぞれユースケース等が異なります。</p><p>PubSub の利点として、標準の WebSocket 接続をサポートしており、各言語の様々な WebSocket クライアント SDK を利用することができる点です。</p><p>また、WebSocket のサブプロトコルにも対応しており、 JSON/Protobuf のサブプロトコルを使用したり、独自にサブプロトコルを実装することもできます。(本記事を書いた際は JSON/Protobuf の 2 種類を用意しています。) 加えて、C# 以外にも JavaScript、Java、Python の SDK にも対応していることも PubSub の強みの 1 つです。</p><p>Azure SignalR を使う利点としては既に ASP.NET Core 等で SignalR をご利用の場合には、比較的開発コストを抑えて Azure SignalR へ移行できます。また、.NET や .NET Core を使用したシステムと統合する必要がある場合(例えば Blazor との連携等) には有力な選択肢となります。</p><p>また、PubSub と比べた時の大きな違いとしては、Azure SignalR は WebSocket だけでなく、Server Send Event や Long Porring 等にも対応しています。そのため、WebSocket に非対応のクライアントを利用している場合もサポートされる HTTP ベースの双方向通信の方式にフォールバックすることが可能です。</p><p>これらのように、Azure SignalR と PubSub では得意なところや不得意なところがそれぞれありますので、もしこれらの利用を検討されている方は、ぜひご自身が作成しようとしているシステムがどのような特性を必要とするか、どのような言語やエコシステムを使用するか等に合わせて利用するサービスを検討してください！その他の違い等については<a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/resource-faq#how-do-i-choose-between-azure-signalr-service-and-azure-web-pubsub-service">こちらの公開情報 (Azure SignalR Service と Azure Web PubSub サービスのどちらかを選択するにはどうすればよいですか?)</a> でも纏められてます。</p><p>なお、余談にはなりますが、もし 現在 ASP.NET Core の SignalR を使用していて、これから Azure SignalR への移行を検討してるという方は、ぜひ<a href="https://microsoft.github.io/jpwebapps/web-apps/MigrationAzureSignalR/">本ブログのこちらの記事</a> もご参考ください！</p><h1 id="チュートリアルでの動作確認"><a href="#チュートリアルでの動作確認" class="headerlink" title="チュートリアルでの動作確認"></a>チュートリアルでの動作確認</h1><p>それでは実際にサンプルを動かしながら動作を確認していきましょう。</p><p>PubSub ではいくつかの公式チュートリアルが用意されていて、コードを触らないで既に用意された<a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/quickstart-live-demo">デモ用のサイトを利用するチュートリアル</a>もありますが、今回は折角なので SDK を用いて各個人でサンプルを試すチュートリアルをいくつかご紹介します。また、Azure SignalR との差別化も含めて、今回は JaveScript(Node.js) の SDK を使用します。</p><p>＊各チュートリアルを完全にトレースすると分量が多くなるので、要所要所をスクリーンショット等を添えて補足していきます。</p><p>＊ Node.js の 12.x 以降が必要となります。</p><h2 id="PubSub-リソースの作成"><a href="#PubSub-リソースの作成" class="headerlink" title="PubSub リソースの作成"></a>PubSub リソースの作成</h2><p>まずは<a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/howto-develop-create-instance">こちらの公開情報(Azure portal から Web PubSub インスタンスを作成する)</a> の手順にそって Azure Portal から PubSub のリソースを作成しましょう。価格レベルはとりあえずこの記事で紹介するチュートリアルを試す目的であれば <code>Free</code> で問題ありません。</p><p><img src="/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/AzureWebPubSub-for-beginner_2021-12-15-22-10-34.png" alt="リソース作成時の画面"></p><p>リソースを無事に作成できたら、以下のキーの項目から、Primary の接続文字列の値をどこかにメモしておきましょう！この後のチュートリアルがスムーズにできます！</p><p><img src="/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/AzureWebPubSub-for-beginner_2021-12-16-01-28-51.png" alt="リソースのキーの確認画面"></p><h3 id="Tips-チュートリアル中に使用する環境変数について"><a href="#Tips-チュートリアル中に使用する環境変数について" class="headerlink" title="Tips : チュートリアル中に使用する環境変数について"></a>Tips : チュートリアル中に使用する環境変数について</h3><p>PubSub のチュートリアルでは基本的に bash を使ったコマンドで紹介されていますが、もしも Windows の PowerShell を使って開発をされている場合には、以下のような <code>$env</code> コマンドで環境変数を設定できます。以下の実行例では、<code>WebPubSubConnectionString</code> という環境変数に <code>&quot;&lt;connection-string&gt;&quot;</code> という String を値として設定しています。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:WebPubSubConnectionString</span>=<span class="string">&quot;&lt;connection-string&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>$env コマンドの詳細は<a href="https://docs.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_environment_variables?view=powershell-7.2#using-and-changing-environment-variables">こちらの公開情報</a>をご確認ください。</p><p>なお、上記の環境変数は PowerShell を閉じたり、別のウィンドウでは効力がありません。そのため、実際の利用等では <code>.env</code> という環境変数用のファイルを作成するのも良いかと思います。ご参考程度ですが、 npm の環境変数用のファイルを扱うモジュールとして、<a href="https://www.npmjs.com/package/dotenv">dotenv というモジュール</a> 等があります。</p><p>今回の記事では Windows の PowerShell で環境変数を設定していきます。</p><h2 id="メッセージの発行とサブスクライブのチュートリアル"><a href="#メッセージの発行とサブスクライブのチュートリアル" class="headerlink" title="メッセージの発行とサブスクライブのチュートリアル"></a>メッセージの発行とサブスクライブのチュートリアル</h2><h3 id="チュートリアルの大まかな流れと実際の画面"><a href="#チュートリアルの大まかな流れと実際の画面" class="headerlink" title="チュートリアルの大まかな流れと実際の画面"></a>チュートリアルの大まかな流れと実際の画面</h3><p><a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/tutorial-pub-sub-messages?tabs=javascript#set-up-the-project">こちらのチュートリアル</a> ではシンプルなコンソールでの動作を確認できます。プログラムとしてはメッセージを受信する側の <code>Subscriber</code> とメッセージを送信する側の <code>Publisher</code> の 2 つがあります。基本的には手順通りにコマンドを実行していくと各プログラム等も完成しますが、こちらの GitHub に<a href="https://github.com/Azure/azure-webpubsub/tree/main/samples/javascript/pubsub">完成したサンプル</a>もあります。</p><p>このサンプルでは以下のような手順で動作を確認します。</p><ol><li>subscriber 側で環境変数を設定する。($env コマンド)</li><li>subscriber を起動する。(node subscribe.js)</li><li>publisher 側で環境変数を設定する。($env コマンド)</li><li>publisher で任意のメッセージを送信する。(node pusblish.js “&lt;任意のメッセージ&gt;”)</li></ol><p>環境変数の設定では、上述の <code>$env</code> コマンド等を使用します。(subscriber と publisher でそれぞれコンソールを用意して、それぞれで環境変数を設定します。)</p><p>実行した場合のコンソール画面は以下のようになります。画面左側は subscriber で、右側が publisher です。画面左側の subscriber で接続が確立して connected となった状態で、publisher 側で引数として指定して実行されたメッセージを subscriber 側に送信しています。<br><img src="/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/AzureWebPubSub-for-beginner_2021-12-16-01-37-31.png" alt="プログラムを実行中のコンソールの様子(左:subscriber 側、右:publisher 側)"></p><h3 id="プログラムの概要"><a href="#プログラムの概要" class="headerlink" title="プログラムの概要"></a>プログラムの概要</h3><p>subscriber 側のプログラムは以下になります。subscriber 側では環境変数を設定した後に、<code>node subscribe.js</code> という風に subscriber を起動するのみです。環境変数で指定した <code>WebPubSubConnectionString</code> の値を基に WebPubSubServiceClient インスタンスを作成して、そこからトークンや接続用の URL を作成していますね。</p><p>main() 関数の後半部分では、正常に動作したら connected という値が表示され、publisher からのメッセージを受け取った際には Message Recieved: &lt;送られたメッセージ&gt; とコンソールに出力するように実装されています。WebSocket のインスタンスである <code>ws</code> を作成してからは特に PubSub 固有の実装ということもなく、一般的な WebSocket と同じような実装ですね！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; WebPubSubServiceClient &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@azure/web-pubsub&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hub = <span class="string">&quot;pubsub&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> service = <span class="keyword">new</span> WebPubSubServiceClient(process.env.WebPubSubConnectionString, hub);</span><br><span class="line">  <span class="keyword">let</span> token = <span class="keyword">await</span> service.getClientAccessToken();</span><br><span class="line">  <span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(token.url);</span><br><span class="line">  ws.on(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;connected&#x27;</span>));</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Message received: %s&#x27;</span>, data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>pusblisher 側のプログラムは以下になります。かなりシンプルなプログラムですね。<code>process.argv[2]</code> というところでプログラム実行時の引数をメッセージとして取得してます。このサンプルでは同じハブにいるユーザー全員にメッセージを送るために PubSub 用に作られた SDK である <code>@azure/web-pubsub</code> を pusblisher 側でも使用していますね。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; WebPubSubServiceClient &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@azure/web-pubsub&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hub = <span class="string">&quot;pubsub&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> service = <span class="keyword">new</span> WebPubSubServiceClient(process.env.WebPubSubConnectionString, hub);</span><br><span class="line"></span><br><span class="line"><span class="comment">// by default it uses `application/json`, specify contentType as `text/plain` if you want plain-text</span></span><br><span class="line">service.sendToAll(process.argv[<span class="number">2</span>], &#123; <span class="attr">contentType</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="WebSocket-のサブプロトコルのチュートリアル"><a href="#WebSocket-のサブプロトコルのチュートリアル" class="headerlink" title="WebSocket のサブプロトコルのチュートリアル"></a>WebSocket のサブプロトコルのチュートリアル</h2><h3 id="WebSocket-のサブプロトコルの概要"><a href="#WebSocket-のサブプロトコルの概要" class="headerlink" title="WebSocket のサブプロトコルの概要"></a>WebSocket のサブプロトコルの概要</h3><p>PubSub の利点の一つとして Websocket のサブプロトコルを使用できます。Websocket のサブプロトコルの大まかなイメージとしては、WebSocket の接続を行う際に、送信するデータに JSON 等の形式の規則を指定できるイメージです。WebSocket のサブプロトコルの詳細については<a href="https://datatracker.ietf.org/doc/html/rfc6455#section-1.9">RFC6455 の WebSocket の項目</a> をご参考ください。</p><h3 id="チュートリアルの大まかな流れと実際の画面-1"><a href="#チュートリアルの大まかな流れと実際の画面-1" class="headerlink" title="チュートリアルの大まかな流れと実際の画面"></a>チュートリアルの大まかな流れと実際の画面</h3><p>今回は、<a href="https://docs.microsoft.com/ja-jp/azure/azure-web-pubsub/tutorial-subprotocol?tabs=csharp">こちらのチュートリアル</a>に沿って試してみようと思います。<a href="https://github.com/Azure/azure-webpubsub/tree/main/samples/javascript/logstream/">GitHub のサンプルもこちら</a> にあります。大まかな全体の流れとしては以下のような流れで行います。</p><ol><li>Web ページをホストするサーバーアプリ側で環境変数を設定する。($env コマンド)</li><li>サーバーアプリを起動する。(node server)</li><li>ブラウザーで <a href="http://localhost:8080/">http://localhost:8080</a> へとアクセスする。</li><li>クライアントアプリを起動する。(node stream)</li><li>クライアントアプリ側でメッセージを送信する。(クライアント側のコンソールでメッセージを入力)</li><li>ブラウザーに送信したメッセージが表示されるのを確認する。</li></ol><p>プログラム実行時のコンソールは以下のようになります。左側が Web ページをホストするサーバーアプリ、右側がクライアントアプリになります。サーバーアプリ側でやることは環境変数を設定してからは起動するのみです。クライアントアプリではクライアントアプリを起動してから、メッセージを入力していきます。<br><img src="/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/AzureWebPubSub-for-beginner_2021-12-15-22-47-20.png" alt="プログラムを実行中のコンソールの様子(左:サーバー側、右:クライアント側)"></p><p>以下のようにクライアント側から送信したメッセージがブラウザー側で表示されていることを確認できます。<br><img src="/jpwebapps/azure-web-pubsub/AzureWebPubSub-for-beginner/AzureWebPubSub-for-beginner_2021-12-16-01-01-20.png" alt="http://localhost:8080 での画面"></p><h3 id="プログラムの概要-1"><a href="#プログラムの概要-1" class="headerlink" title="プログラムの概要"></a>プログラムの概要</h3><p>Web ページをホストするサーバー 側のプログラムは以下のようになっています。先程の subscriber のプログラムと大きく違う点として、express というモジュールを使用して、サーバーアプリ化していますね。</p><p>また、クライアントが使用する Token に WebPubSubServiceClient のインスタンスのメソッドを使って roles を指定してます。これにより、クライアントが stream グループに対してメッセージを送ることや、グループへの参加/脱退が可能となります。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; WebPubSubServiceClient &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@azure/web-pubsub&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> endpoint = <span class="keyword">new</span> WebPubSubServiceClient(process.env.WebPubSubConnectionString, <span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/negotiate&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="keyword">await</span> endpoint.getClientAccessToken(&#123;</span><br><span class="line">    <span class="attr">roles</span>: [<span class="string">&#x27;webpubsub.sendToGroup.stream&#x27;</span>, <span class="string">&#x27;webpubsub.joinLeaveGroup.stream&#x27;</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    <span class="attr">url</span>: token.url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;server started&#x27;</span>));</span><br></pre></td></tr></table></figure><p>ブラウザー側で開いている .html ファイルより一部を抜粋したコードが以下です。WebSocket の message のイベントを検出した際に、ページ上にクライアントから送られてきたメッセージをログのように表示させます。また、WebSocket のインスタンスを作成する時に、第 2 引数として <code>&#39;json.webpubsub.azure.v1&#39;</code> と入力しています。これが、今回使用する JSON 向けに用意されたサブプロトコルです。</p><p>また、ws.send の際に JSON.stringfy() 関数で JSON に成形していることが確認できますね。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;/negotiate&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> data = <span class="keyword">await</span> res.json();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(data.url, <span class="string">&#x27;json.webpubsub.azure.v1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ackId = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      ws.onopen = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;connected&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        ws.send(<span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="string">&#x27;joinGroup&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">group</span>: <span class="string">&#x27;stream&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">ackId</span>: ++ackId,</span></span><br><span class="line"><span class="javascript">        &#125;));</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> output = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#output&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      ws.onmessage = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> message = <span class="built_in">JSON</span>.parse(event.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (message.type === <span class="string">&#x27;message&#x27;</span> &amp;&amp; message.group === <span class="string">&#x27;stream&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> d = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="javascript">          d.innerText = message.data;</span></span><br><span class="line"><span class="javascript">          output.appendChild(d);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="built_in">document</span>.body.scrollHeight);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;)();</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>クライアント側のプログラムは以下になります。先程のチュートリアルと比べると少し記述は増えてますね。先程の .html 同様に ws.send で送る値を JSON に変換しています。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">`http://localhost:8080/negotiate`</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> res.json();</span><br><span class="line">  <span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(data.url, <span class="string">&#x27;json.webpubsub.azure.v1&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> ackId = <span class="number">0</span>;</span><br><span class="line">  ws.on(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    process.stdin.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      ws.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;sendToGroup&#x27;</span>,</span><br><span class="line">        <span class="attr">group</span>: <span class="string">&#x27;stream&#x27;</span>,</span><br><span class="line">        <span class="attr">ackId</span>: ++ackId,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: data.toString()</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Received: %s&quot;</span>, data));</span><br><span class="line">  process.stdin.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> ws.close());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>他にもいくつかチュートリアルはありますが、今回は分量など含めてここまでとなります。双方向通信の仕組みやサービスは色々と出回っていますが、ぜひ今後の選択肢として Azure Web PubSub サービスもご検討いただけたら嬉しいです！</p><p>まだまだ一般公開されたばかりのサービスですので、今後もっと発展するとより皆さんのご要望にそった機能等も追加されるかもしれませんので、ぜひよろしくお願いします。それでは、また次回！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;＊本記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2021/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2021&lt;/a&gt; の 20 日目の記事になります</summary>
      
    
    
    
    
    <category term="Azure Web PubSub Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Web-PubSub-Service/"/>
    
  </entry>
  
  <entry>
    <title>Bot Framework Composer を用いた Azure Bot 構築</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-bot-service/bot-merry-christmas/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-bot-service/bot-merry-christmas/</id>
    <published>2021-12-07T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.356Z</updated>
    
    <content type="html"><![CDATA[<p>ちょっと早いですが Merry Christmas！Azure Bot Service サポート チームの石沢です！</p><p>皆様、Bot Framework Composer をご存じですか？なんとこれを利用すればノンコーディングでも Bot を構築することが可能です！<br>Bot でサービス構築したいけどコーディングはちょっと…という方でも GUI を操作するだけで構築完了してしまう優れものです。<br>今回は初めての Bot Framework Composer を利用される方向けに、Merry Christmas と話しかけると Merry Christmas と返してくれる、こちらから話しかけた内容をそのままオウム返ししてくる Bot を Azure 上に構築してみます。</p><hr><p>Bot Framework Composer を利用するにあたって、以下のソフトウェアのインストールする必要があります。<br>本記事では、Node.js は 17.2.0、.NET Core SDK は 3.1.21、Composer は 2.0.0 バージョンを使用しました。</p><p>・Node.js (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)</p><p>・.NET Core SDK 3.1 以降 (<a href="https://dotnet.microsoft.com/download/dotnet/3.1">https://dotnet.microsoft.com/download/dotnet/3.1</a>)</p><p>・Composer (<a href="https://aka.ms/bf-composer-download-win">https://aka.ms/bf-composer-download-win</a>)</p><p>参考：Install Bot Framework Composer - Prerequisites<br><a href="https://docs.microsoft.com/en-us/composer/install-composer?tabs=windows#prerequisites">https://docs.microsoft.com/en-us/composer/install-composer?tabs=windows#prerequisites</a></p><hr><h1 id="1-Composer-を起動して-Bot-を作成しよう！"><a href="#1-Composer-を起動して-Bot-を作成しよう！" class="headerlink" title="1. Composer を起動して Bot を作成しよう！"></a>1. Composer を起動して Bot を作成しよう！</h1><p>それでは早速インストールした Composer を起動しましょう。<br>Composer を起動すると以下の画面が表示されますので、おもむろに [+ Create New] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-01.png" alt="Step1"></p><p>表示された画面で、最もシンプルな Bot のテンプレートである “Empty Bot” を選択して、[Next] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-02.png" alt="Step2"></p><p>次の画面ではこの Bot のプロジェクトに名前を付けてあげましょう。あわせて Bot が保存されるフォルダも指定してあげてください。<br>ここでは Runtime type は “Azure Web App” が設定されていることを確認して、[Create] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-03.png" alt="Step3"></p><hr><h1 id="2-Bot-を編集しよう！"><a href="#2-Bot-を編集しよう！" class="headerlink" title="2. Bot を編集しよう！"></a>2. Bot を編集しよう！</h1><p>さて、Create が無事完了すると以下のような画面に遷移します。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-04.png" alt="Step4"></p><p>ここで左のナビゲーションパネルから、”Unknown intent” をクリックして、さらに “Send a response” をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-05.png" alt="Step5"></p><p>“Unknown intent” では、ユーザーの入力が Bot 側でよくわからないものと認識された場合の処理フローが示されています。<br>今回の “Empty Bot” テンプレートの場合は、入力を認識するような処理は入っていないので、ユーザーの全ての入力がこのフローに入ります。<br>なんとなく想像できるのではないかと思いますが、ここでユーザーの入力をそのまま返すようにフローを書き替えるだけで、Merry Christmas という入力にたいして Merry Christmas という応答を返す Bot が完成します。<br>フローを書き替えるためには、まず右のパネルに表示された “Add alternative” をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-06.png" alt="Step6"></p><p>ここで Bot が返すテキストを設定できるのですが、入力されたユーザーのテキストを示すプロパティを選択します。”{x}” をクリックして、”turn.activity.text” を選択します。 </p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-07.png" alt="Step7"></p><p>選択できたら、”Sorry, I didn’t get that.” というレスポンスは不要なので、”Remove variation” をクリックして削除してしまいましょう。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-08.png" alt="Step8"></p><p>これでオウム返しする Bot が完成しました！</p><hr><h1 id="3-Bot-を-ローカルでテストしよう！"><a href="#3-Bot-を-ローカルでテストしよう！" class="headerlink" title="3. Bot を ローカルでテストしよう！"></a>3. Bot を ローカルでテストしよう！</h1><p>Composer ではローカルでのテストも容易に行うことができます！<br>後日記事を追記いたしますので、今しばらくお待ちください。</p><hr><h1 id="4-Bot-を-Publishしよう！"><a href="#4-Bot-を-Publishしよう！" class="headerlink" title="4. Bot を Publishしよう！"></a>4. Bot を Publishしよう！</h1><p>さて、あとは作成した Bot を Azure 上に Deploy して Publish するだけです。<br>これも GUI でぽちぽちするだけでできます。Composer の雲のマークのメニューを選択して、”Publishing profile” タブを選択して、さらに [Add new] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-09.png" alt="Step9"></p><p>ここで Publish 用のプロファイルを作成します。Name は任意のものを入力し、Publishing target には “Publish bot to Azure” を選択して、[Next] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-10.png" alt="Step10"><br>次に Bot を動作させるために新しいリソースを作成するか、既存のリソースをインポートするかを選択します。<br>ここでは、新しくリソースを作成するため “Create new resources” を選択して、[Next] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-11.png" alt="Step11"></p><p>Azure アカウントへのログインが求められるのでログインします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-12.png" alt="Step12"></p><p>ログインできたら、利用するサブスクリプションや Resource group についての設定を行い、[Next] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-13.png" alt="Step13"></p><p>次に追加するリソースを選択します。今回の目的の通り動作させるだけであれば “Required” 以外は追加しなくても問題ありません。</p><p>確認画面が出てくるので、問題なさそうであれば [Create] をクリックして、リソースのデプロイが完了するのを待ちましょう。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-14.png" alt="Step14"></p><p>以下のようなメッセージが表示されれば OK です！</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-15.png" alt="Step15"></p><p>次に “Publish” タブを選択してから、パブリッシュしたい Bot にチェックを入れて、先ほど作成したプロファイルを “Publish target” に設定したら [Publish selected bots] をクリックします。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-16.png" alt="Step16"></p><p>次の画面では、Comments に任意のコメントを入れて、[Okay] をクリックして Publish の完了を待ちましょう。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-17.png" alt="Step17"></p><p>Publish が成功しているかどうかは、Message に ”Success” と表示されていることで確認できます。</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-18.png" alt="Step18"></p><hr><h1 id="5-Bot-の動作確認をしよう！"><a href="#5-Bot-の動作確認をしよう！" class="headerlink" title="5. Bot の動作確認をしよう！"></a>5. Bot の動作確認をしよう！</h1><p>ここでは詳細は割愛しますが、Azure Portal にアクセスして、作成した Azure Bot リソースから、”Web チャットでテスト” で実際に動作させてみるのが最も簡単な動作確認方法でしょう。<br>当初の目的であった “Merry Christmas と話しかけると Merry Christmas と返してくれる Bot を Azure 上に構築する” が達成できたことを確認できます！</p><p><img src="/jpwebapps/azure-bot-service/bot-merry-christmas/bot-merry-christmas-18.png" alt="Step19"></p><p>というわけで 1 つもコーディングせずに Bot の構築ができてしまいました！<br>今回は以上です。それでは、また次回！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ちょっと早いですが Merry Christmas！Azure Bot Service サポート チームの石沢です！&lt;/p&gt;
&lt;p&gt;皆様、Bot Framework Composer をご存じですか？なんとこれを利用すればノンコーディングでも Bot を構築することが可能で</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Career&gt;&lt;第二弾&gt; インターンから見た Microsoft と Developer Support Internet (DSI) チーム (2021)</title>
    <link href="https://microsoft.github.io/jpwebapps/general/career2-intern-experience/"/>
    <id>https://microsoft.github.io/jpwebapps/general/career2-intern-experience/</id>
    <published>2021-11-24T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.377Z</updated>
    
    <content type="html"><![CDATA[<p>＊本記事はこれから日本マイクロソフトのインターンシップ、あるいは就職先として考える学生に向けて、実際に 2021 年のサマーインターンシップに参加してもらった学生に書いてもらいました。<br>インターン生の率直な感想を皆さんにお伝えするために、普段の内容より少々くだけた表現となっておりますのでご了承ください。<br>以下からが本文となります。</p><p>こんにちは！CSS Developer Support Internet チームでサマーインターンシップに参加しております宮脇（Miyawaki）と申します。<br>本記事では、私が Microsoft Japan で働いてみた所感と将来のインターン生、今後マイクロソフトを就職先に考える学生に向けた Tips をまとめようと思います。</p><p>例えば、以下のような質問に、私見ではありますが回答できればと思います。</p><ul><li>  インターンシップには参加したいけど、不安……</li><li>  Microsoft のインターンシップって何をするの？</li><li>  インターンシップ期間は長いけど、他のことは何もできなくなるの？</li></ul><p>目次は以下の通りです。</p><ol><li> Microsoft のミッション</li><li> Customer Service &amp; Support (CSS) Developer Support Internet について</li><li> インターンシップで行ったこと（私の場合）</li><li> インターンシップでの学び・所感</li></ol><p>それでは、Let’s Explorer the Internship at Microsoft!</p><hr><p>2021 年度の場合は、1 ヵ月半のインターンシップのうち、最初の一週間に <strong>“Intern Learning Week”</strong> という期間が設けられていて、Microsoft の mission や culture について知ることができました。</p><blockquote><p><strong>Our Mission : Empower every person and every organization on the planet to achieve more.（地球上のすべての個人とすべての組織が、より多くのことを達成できるようにする）</strong><br><strong>Culture</strong> :</p><ul><li>  GROWTH MINDSET（成長する考え方）</li><li>  CUSTOMER OBSESSED（お客様に寄り添う）</li><li>  DIVERSITY AND INCLUSION（ダイバーシティ &amp; インクルージョン）</li><li>  ONE MICROSOFT（ワン・マイクロソフト）</li><li>MAKING A DIFFERENCE（世界を変える）<br>  参考 : <a href="https://www.microsoft.com/ja-jp/mscorp/college/msd-company-mv.aspx">https://www.microsoft.com/ja-jp/mscorp/college/msd-company-mv.aspx</a></li></ul></blockquote><p>Intern Learning Week で学べる Microsoft のいわゆる「社訓・社風」はすべて上に詰まっているといっても過言ではないでしょう。</p><p>ちなみに私が最も好きな Culture は “ONE MICROSOFT” です！<br>チームとしての Microsoft の団結力は限りなく強固で、他者貢献の意識を非常に重要視しています。<br>インターンシップに参加していただくことで、よりリアルに肌で感じることができるのではないかと思います。</p><h1 id="2-Customer-Service-amp-Support-CSS-Developer-Support-Internet-について"><a href="#2-Customer-Service-amp-Support-CSS-Developer-Support-Internet-について" class="headerlink" title="2. Customer Service &amp; Support (CSS) Developer Support Internet について"></a>2. Customer Service &amp; Support (CSS) Developer Support Internet について</h1><p>Customer Service &amp; Support (CSS) は、Microsoft の製品／サービスを利用するお客様をサポートし、Empower していく役割を担っています。<br>その中でも、私が所属した Developer Support Internet (DSI) は、Edge, Internet Explorer, IIS (Internet Information Services), Azure Bot Service といったサービスのサポートをを担当しています。</p><p>私は「サポート業務」というと、電話の受け答えを淡々と行う業務かと思っていました。<br>しかし、実際には顧客目線で出来るだけ早く的確な返答を行う高度なコミュニケーション、担当分野に対する専門的で幅広い技術知識、チーム内外での連携するチームワークといったプロフェッショナルスキルを要求される業務でした。  </p><p>この点については、Microsoft の Culture である “ONE MICROSOFT” や “CUSTOMER OBSESSED” を社員全員が意識している結果が反映されているのではと考えています。</p><h1 id="3-インターンシップで行ったこと"><a href="#3-インターンシップで行ったこと" class="headerlink" title="3. インターンシップで行ったこと"></a>3. インターンシップで行ったこと</h1><p>インターンシップでは、大きく下の 3 つについて取り組みました。</p><ul><li>  <strong>チーム内業務</strong></li><li>  <strong>インターン生同士のプロジェクト</strong></li><li>  <strong>インターン生個人の活動</strong></li></ul><p>まず<strong>チーム内業務</strong>について、こちらはみなさんが主にイメージしているインターンシップの内容と一致していると思います。<br>具体的には、CSS のサポート業務の一連の流れについての理解、DSI で担当しているサービスの体験、関連する知識の学習、模擬サポート業務体験が挙げられます。</p><p>次に<strong>インターン生同士のプロジェクト</strong>について、これは今年度 (FY21) に取り組まれたサマーインターンシップのイベントです。<br>人事の方が用意してくださった 4 つのテーマから一つ選び、インターン生同士が協力してプロジェクトに取り組みます。<br>参考までに、私は日本マイクロソフトの組織内に存在するコミュニティーからゲストをお呼びして、<br>インターン生と社員の交流を促進するためのプロジェクトに所属して、交流の場を儲けるイベントを開催しました。</p><p>最後に<strong>インターン生個人の活動</strong>について、こちらはインターン生がメンターやマネージャーと相談し、目標とやることを明確にしたうえで業務時間中に取り組む活動です。<br>正直、何をするのかはみなさん次第だと思います。以前のインターン生の活動履歴や、インターンシップ応募時に提出した履歴書の内容がヒントになるかもしれません！  </p><p>参考までに、私は DSI 内と CSS 全体でそれぞれ勉強会を開催しました。</p><p>通常のインターンシップでは味わえないほど、リアルで濃い体験ができると思います。<br>もちろん、メンターやその他社員の方が相談に乗ってくださりますので、のびのびと活動できるかと思います！</p><h1 id="4-インターンシップでの学び・所感"><a href="#4-インターンシップでの学び・所感" class="headerlink" title="4. インターンシップでの学び・所感"></a>4. インターンシップでの学び・所感</h1><p>次に、インターンシップでの学びについて簡単にまとめさせていただきます</p><ul><li>  <strong>コミュニケーション x 技術</strong></li><li>  <strong>GROWTH MINDSET</strong></li></ul><p>最初に<strong>コミュニケーション x 技術</strong>について、これは私がこれからのキャリアを考えたときに、Microsoft でフル活用できると思ったスキルです。 これらは単体でなくセットになったとき初めて CSS で活かされるのだと思います。  </p><p>具体的にコミュニケーションでは、迅速な返答、わかりやすく言語化する能力、相手の考えていることを推察する能力、お客様に合わせた柔軟な言葉選び等が該当します。<br>そして技術では、製品／サービスに対する知識、トラブルシューティング能力、既存の知識とトラブル発生の現状を結びつける能力等が該当します。</p><p>ただし、決して私も最初からこのような能力があったわけではありませんし、今も全て備えているわけではありません。<br>それよりもむしろ、インターンシップを通して業務に必要とされている能力と自身に足りない点が<strong>明確になった</strong>と考えています。そういった点で、インターンシップは有意義でした。</p><p>次に<strong>GROWTH MINDSET</strong> について、こちらは Microsoft の Culture からの引用です。<br>本インターンシップを通して学んだのは、「GROWTH MINDSET （成長し続ける心）の醸成には明確な目的と行動が必要であること」であり、Microsoft のインターンシップではそれらが実践できます。</p><p><strong>今までしてきたことよりも、何をするのか？またその行動の明確な目標と想定されるインパクトは考えているか？</strong><br>この実践は、これからのキャリア形成のときにも活かされるのではないかと思います。</p><p>……と、上では抽象的でポジティブなことばかり書いてきました。<br>そこで、苦労したことについても取り上げようかと思います。</p><p>私がインターンシップで苦労したこと、それは<strong>自身の体力・時間の確保</strong>です。<br>私は本インターンシップに加えて、大学院での研究活動、各種作品コンテストの制作等を並行してきました。</p><p>なんとなく想像できるかと思いますが、これらすべてを並行して両立することは物理的に難しいです。<br>どれかが中途半端にならないように、スケジューリングとキャパシティの把握には気を付けておくべきかなと思います。</p><p>以上、少しリアルなことについても書きましたが、成長意欲と他人の役に立ちたいという意思を持っておられる方、そしてなにより Microsoft とそのテクノロジーに興味を持っている方は、Microsoft のインターンシップに参加するべきです！<br>他社では味わえない、リアルな体験があなたを待っています！</p><hr><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>長くなってしまいましたが、インターンシップに参加する方、また参加を検討されている方のお役に立てるのであれば幸いです。<br>皆さんにとって最高の夏になりますように！<strong>Come as you are!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;＊本記事はこれから日本マイクロソフトのインターンシップ、あるいは就職先として考える学生に向けて、実際に 2021 年のサマーインターンシップに参加してもらった学生に書いてもらいました。&lt;br&gt;インターン生の率直な感想を皆さんにお伝えするために、普段の内容より少々くだけた表現</summary>
      
    
    
    
    
    <category term="チーム紹介" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%81%E3%83%BC%E3%83%A0%E7%B4%B9%E4%BB%8B/"/>
    
    <category term="インターンシップ" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%83%E3%83%97/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Career&gt;&lt;第一弾&gt; Developer Support Internet (DSI) ってどのような製品の技術サポートをしているの？</title>
    <link href="https://microsoft.github.io/jpwebapps/general/career1-dsi-technologies/"/>
    <id>https://microsoft.github.io/jpwebapps/general/career1-dsi-technologies/</id>
    <published>2021-11-01T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.377Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Developer Support Internet (DSI) サポート チームの大嶋です。 </p><p>この度は少し前から <a href="https://careers.microsoft.com/us/en/job/1113264/Support-Engineer-Developer">我々の DSI チームで採用活動が再開</a> したこともあり、ぜひ我々のチーム DSI ってどういうチームなのか？を知っていただきたいという思いから、チーム紹介の Blog を開始します！</p><p>今回は第一弾ということで、シンプルに我々のチームがサポートしている技術製品を紹介し、テクニカルな面にフォーカスしお話しします。</p><p>Developer Support チームということで、お客様の課題解決のために、技術的に幅広く難易度の高い様々な開発系のお問い合わせに触れられることが醍醐味の 1 つであり、それぞれカテゴリごとに技術的な面白さを少しばかりご紹介したいと思います。ちなみに、我々のチームは現在はフルリモートで働いており、既に完全リモートワークを開始して約 1 年半以上が経ちます。(2021 年 11 月現在)</p><hr><h3 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h3><ul><li><a href="#Developer-Support-Internet-%E3%81%8C%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B%E6%8A%80%E8%A1%93%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA%E3%81%AF">Developer Support Internet がサポートする技術カテゴリは？</a><ul><li><a href="#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E9%A0%98%E5%9F%9F">ブラウザ領域</a></li><li><a href="#Web-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%BBWeb-%E3%82%A2%E3%83%97%E3%83%AA%E9%A0%98%E5%9F%9F">Web サーバー・Web アプリ領域</a></li><li><a href="#Azure-%E9%A0%98%E5%9F%9F">Azure 領域</a></li></ul></li><li><a href="#%E6%9C%80%E5%BE%8C%E3%81%AB">最後に</a><ul><li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li><li><a href="#%E7%8F%BE%E5%9C%A8%E6%88%91%E3%81%AE%E3%83%81%E3%83%BC%E3%83%A0%E3%81%AF%E6%8E%A1%E7%94%A8%E4%B8%AD%E3%81%A7%E3%81%99">現在、我々のチームは採用中です！！</a></li></ul></li></ul><hr><h2 id="Developer-Support-Internet-がサポートする技術カテゴリは？"><a href="#Developer-Support-Internet-がサポートする技術カテゴリは？" class="headerlink" title="Developer Support Internet がサポートする技術カテゴリは？"></a>Developer Support Internet がサポートする技術カテゴリは？</h2><p>その名の通り Developer Support 部門の Internet 周りを担当しているチームのため、主な範囲は Web 系の技術全般と多種多様です。</p><p>まず、大きく分けて、オンプレミス製品は Web のクライアントサイドとして Web ブラウザ、サーバーサイドとして Web サーバー・アプリの 2 つのカテゴリがあります。更に、オンプレミス製品のみならず、以下に挙げた Azure 製品カテゴリも一部サポートしております。</p><ul><li>ブラウザ : Chromium ベースの Microsoft Edge, WebView2, IE モード, Internet Explorer etc…</li><li>Web サーバー・Web アプリ : IIS (Internet Information Services), ASP.NET, ASP.NET Core, Blazor etc… </li><li>Azure : Azure Bot Service, Bot Framework SDK, Azure SignalR Service, Azure PubSub Service</li></ul><p>各製品の開発はグローバルで行っているため海外の各関連部門と連携する機会もあり、楽しみの 1 つです。また、DSI のサポートエンジニアの中でも各カテゴリの中で得意領域等がありますが、Web ブラウザ領域は現在 DSI チーム全員で担当している領域です。</p><p>それでは、それぞれの紹介を深掘りしていきましょう。</p><h3 id="ブラウザ領域"><a href="#ブラウザ領域" class="headerlink" title="ブラウザ領域"></a>ブラウザ領域</h3><p>Web ブラウザのサポート領域は Chromium ベースの <a href="https://www.microsoft.com/ja-jp/edge?r=1">Microsoft Edge</a>, <a href="https://docs.microsoft.com/ja-jp/microsoft-edge/webview2/">Microsoft Edge WebView2</a>, Internet Explorer、それに付随するコンポーネントとなり、多岐に渡ります。また、Chromium ベースの 新しい Microsoft Edge は Windows だけでなく、Linux や Mobile (Android や iOS) でも動作します。</p><p>そのため、調査・解析にあたって、技術的に触れることができる領域というのもそれに伴い、数えきれないほど多様なエリアとなります。Microsoft Edge の加速化に伴い、お問い合わせも日々増加傾向にあり、以前より更にお問い合わせ内容の幅も大きく広がっています。また Web ブラウザ領域は現在 DSI チーム全員で担当していることもあり、それぞれのエンジニアが感じる魅力も異なるのでは？という疑問から実際に複数人にヒアリングをしてみました。以下に回答いただいた魅力の一部を紹介します。</p><ul><li>ブラウザは世界中のユーザーが、必ず利用する様々なサービスの入り口となる存在で必要不可欠であり、OS に匹敵する巨大なプラットフォームで最先端の Web 技術に触れられる</li><li>通信ログやパケット、メモリダンプ等の様々なレイヤーの情報を状況毎に多角的に判断・利用し、最終的にお客様の問題解決ができたことに喜びを感じる</li><li>Microsoft Edge も採用した Chromium のサポートを通じてグローバルのモダンな Web 業界の発展に貢献できる</li><li>ブラウー サポートの職という希少なプロフェッショナルとして働くことができ、世界的なシェア向上に貢献できる</li><li>バージョンアップのスピードが加速しており、大変な面もある反面、より新しいことができるようになる瞬間を身近に感じることができる</li></ul><p>ここに記載出来ない魅力も沢山あります。少しでも興味を持ち、アプリケーションの中でも稀有なブラウザに興味がある、Edge のシェアを伸ばしたい、Web 技術の発展の一端に触れたいといった方はぜひ我々と一緒に働きましょう！下部の応募サイトにてお待ちしております。</p><h3 id="Web-サーバー・Web-アプリ領域"><a href="#Web-サーバー・Web-アプリ領域" class="headerlink" title="Web サーバー・Web アプリ領域"></a>Web サーバー・Web アプリ領域</h3><p>それでは今度は別のカテゴリに移ります。我々のサポートする Web サーバー・Web アプリ領域も近年、実は Web ブラウザ同様、多様化しております。</p><p>まず、古くからサポートしている Microsoft の各種 Web 製品を支えている以下の 3 つが挙げられます。</p><ul><li><a href="https://docs.microsoft.com/en-us/iis/get-started/introduction-to-iis/introduction-to-iis-architecture">IIS (Windows に標準搭載されている歴史の長い Web サーバー製品)</a></li><li><a href="https://www.iis.net/downloads/microsoft/application-request-routing">ARR (Application Request Routing / リバース プロキシ・L7 Load Balancer の機能を搭載するサービス)</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/overview">ASP.NET (.NET Framework ベースの Web アプリケーションのプラットフォーム/フレームワーク)</a></li></ul><p>上記の各コンポーネントは各種 Office 製品や Azure 製品の基盤としても利用されているものもあり、クラウド化が進む現在でも、重要な技術の 1 つです。また、内部的に Windows OS の各標準コンポーネントを利用していることから、関連チームともコラボレーションをしながら OS のネットワークレイヤーや認証等の幅広い知識にも触れることができます。また、Classic ASP や WCF といったテクノロジーもサポートしています。</p><p>更に近年は、Windows OS 上の Web アプリ開発には留まりません。Microsoft はクロス プラットフォーム化にも力を入れており、DSI ではクロス プラットフォームで動作する以下の製品をサポートしています。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-5.0">ASP.NET Core (MVC, Web API, Razor, Blazor WebAssembly etc…)</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/signalr/introduction?view=aspnetcore-5.0">ASP.NET Core SignalR</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/grpc/?view=aspnetcore-5.0">gRPC on .NET</a></li></ul><p>macOS や Linux 上、もちろん Linux コンテナ上でも動作が可能な .NET Core/.NET ベースの ASP.NET Core という Web アプリ開発のプラットフォーム、それに付随する MVC や Web API 等の ASP.NET Core 用のフレームワークをサポートしております。ASP.NET と異なり、ASP.NET Core は IIS にも Windows OS にも縛られません！</p><p>更には、サーバーサイドにも留まらず、WebAssembly (wasm) を活用したフロントエンド フレームワーク Blazor wasm もサポートしており、近年注目が集まる wasm の最新技術の一端に触れることもできます。加えて、WebSockets を含む双方向通信をサポートするための ASP.NET Core SignalR というフレームワークや .NET の gRPC もサポートしており、多様化するプロトコルもサポート範囲となります。</p><h3 id="Azure-領域"><a href="#Azure-領域" class="headerlink" title="Azure 領域"></a>Azure 領域</h3><p>本チームの特徴は、上記のオンプレミス製品に加えて、以下の Azure クラウド製品にも触れることができる点です。</p><ul><li><a href="https://azure.microsoft.com/ja-jp/services/bot-services/">Azure Bot Service</a> / <a href="https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-overview?view=azure-bot-service-4.0">Bot Framework SDK</a></li><li><a href="https://docs.microsoft.com/ja-jp/azure/azure-signalr/signalr-overview">Azure SignalR Service</a> / <a href="https://azure.microsoft.com/ja-jp/services/web-pubsub/#overview">Azure PubSub Service (Preview)</a></li></ul><p>Azure Bot Service と Bot Framework SDK を利用することで、Bot アプリを開発・運用が可能です。Web Chat という Web アプリ用のクライアントに加えて、Teams やサードパーティ製の LINE や Slack 等様々なクライアントチャンネルをサポートしていることも特徴の一つです。</p><p>また、Bot Framework SDK は C# (.NET Core) だけでなく、JavaScript (Node.js) や Python といった別のプログラミング言語に触れることもできます。</p><p>加えて、Azure Bot Service を利用している場合の多くは <a href="https://azure.microsoft.com/ja-jp/services/app-service/web/">Azure Web Apps という PaaS サービス)</a> に Bot アプリをホストしてお客様が多いことから、Azure Web Apps の専任チームと連携をしながら、PaaS の知識も蓄えることができます。また、Azure 製品という側面から、他の Azure PaaS、Azure Net、Azure AI 部門等の他の各 Azure 製品のサポート チームと連携が必要不可欠で、それらの Cloud に関する知識も得られます。</p><p>更に、Azure SignalR Service や Azure PubSub Service (Preview) 製品をサポートしており、WebSockets を含む双方向通信等の知識が必要となる Azure マネージドな製品の技術支援も行っております。</p><hr><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><h3 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h3><p>Developer Support Internet チームでは、技術的な面は勿論のこと、技術以外にも伝えきれないほどの魅力、多くのやりがいがまだまだございます。長くなってしまうので、我々のチームならではの上記以外の部分のご紹介は次回以降に持ち越しますが、”Microsoft のテクニカルサポートの魅力や一般的な仕事内容自体が気になる” という方向けに、同じサポート部門の方の以下 2 つの記事のご紹介をして終わろうと思います。</p><p><a href="https://jpaztech.github.io/blog/other/technical_support_engineer_explained/">なぜ今サポートエンジニアが熱いか</a><br><a href="https://www.microsoft.com/ja-jp/mscorp/mid-career/interview-rika.aspx">Escalation Engineer の Rika さんのインタビュー</a></p><p>さらに、動画でも我々テクニカルサポート部門の仕事をご紹介してます。ぜひこちらもご覧ください。</p><p><a href="https://youtu.be/xj4Ovso7M4U">マイクロソフト カスタマーサービス＆サポート ‐ How we deliver best customer experience | 日本マイクロソフト</a></p><h3 id="現在、我々のチームは採用中です！！"><a href="#現在、我々のチームは採用中です！！" class="headerlink" title="現在、我々のチームは採用中です！！"></a>現在、我々のチームは採用中です！！</h3><p>最後に、我々 <strong>Developer Support Internet チームも、採用活動中</strong>です。少しでもご興味を持っていただいた方は、以下から現在ご応募をお待ちしております！</p><p><a href="https://careers.microsoft.com/us/en/job/1113264/Support-Engineer-Developer">Developer Support Internet (DSI) チームの採用応募ページ</a><br>※ あくまで現在 11/2 時点で採用活動中であり、タイミングによって採用が終了している、上記リンクが有効でない可能性もございますので、その点ご了承ください。</p><p>そして、本ブログ内容を見て、まだその分野に詳しくない…技術的なスキルに不安がある…という方、少しでも上記の内容に興味があれば、ぜひご応募をお待ちしております。技術的な部分は本業務を通じて学べる環境がありますし、チームでフォローしていますのでご安心ください！そのため、上記の募集要項に満たないけど、興味がありぜひ受けてみたいという方も、まずはご応募をご検討ください！</p><p>なお、本チームだけではなく、Microsoft やテクニカルサポートの仕事等に興味が出てきたという方は、Microsoft では様々な多種多様な職種を募集しております。ぜひ以下の募集から興味のあるチームを探してみて頂ければと思います。</p><p><a href="https://careers.microsoft.com/us/en">Microsoft Careers - Microsoft 採用検索サイト</a><br><a href="https://www.microsoft.com/ja-jp/mscorp/mid-career/event.aspx">サポートエンジニア - キャリアイベント</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Developer Support Internet (DSI) サポート チームの大嶋です。 &lt;/p&gt;
&lt;p&gt;この度は少し前から &lt;a href=&quot;https://careers.microsoft.com/us/en/job/1113264/Support-</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
    <category term="チーム紹介" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%81%E3%83%BC%E3%83%A0%E7%B4%B9%E4%BB%8B/"/>
    
    <category term="Microsoft Edge" scheme="https://microsoft.github.io/jpwebapps/tags/Microsoft-Edge/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET で 拡張子のない URL にてアクセスすると、追加したカスタム ISAPI 拡張ハンドラーが動作しない現象について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/isapi-wildcard/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/isapi-wildcard/</id>
    <published>2021-08-30T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.397Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです！  </p><p>Windows Server 2012 以降の OS バージョンの IIS (IIS 8.0 以降) にて、カスタムの ISAPI 拡張 (ハンドラー) をワイルドカード マッピングを利用して動作させたい場合に、ASP.NET の機能との関連で動作しない現象について、お知らせします。</p><p>   <a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525172(v=vs.90)">ISAPI 拡張について</a></p><h2 id="現象"><a href="#現象" class="headerlink" title="現象"></a>現象</h2><p> IIS 10.0 , ASP.NET の環境下で、 要求パス に “*” を指定した ISAPI 拡張をハンドラーに追加した場合、 拡張子のない URL でアクセスすると、追加した ISAPI 拡張ハンドラーが動作しない。</p><p> コマンド例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appcmd set config &quot;Default Web Site&quot; /section:handlers /+&quot;[name=&#x27;ISAPI_Extension&#x27;, path=&#x27;*&#x27;, verb=&#x27;*&#x27;, modules=&#x27;IsapiModule&#x27;, scriptProcessor=&#x27;C:\ISAPI\ISAPI_Extension.dll&#x27;, resourceType=&#x27;Unspecified&#x27;, requireAccess=&#x27;None&#x27;,preCondition=&#x27;bitness64&#x27;]&quot; /commit:APPHOST</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>ASP.NET がインストールされていると既定で 要求パス “*.” に対して Extensionless URL Handler がマップされ、拡張子のない URL は Extensionless URL Handler に処理されるようになります。</p><p>この動作により 要求パスに “*” を指定した場合に、 Extensionless URL Handler が処理する動作となり、追加した ISAPI 拡張機能は機能しません。</p><p> ASP.NET の場合、 MVC で処理される拡張子のない URL へのリクエストを処理できるようにするために意図的に実装した動作になります。</p><h2 id="対処方法"><a href="#対処方法" class="headerlink" title="対処方法"></a>対処方法</h2><p>拡張子のない URL からアクセスするためには、追加する ISAPI 拡張ハンドラーの要求パスに “*.” を指定します。</p><p>なお、拡張子の有無に関わらず 全ての URL に対して 動作するようにするように ハンドラー を追加するためには、 要求パス に “*“ を指定した ハンドラー と “*.” を指定したハンドラー の 2 つを追加し、順序を上にすることで 拡張子の有無に関わらず、全ての URL に対して 動作することができます。</p><p><img src="/jpwebapps/web-apps/isapi-wildcard/isapi-wildcard_2021-08-31-11-03-24.png" alt="ハンドラーマッピングの設定"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです！  &lt;/p&gt;
&lt;p&gt;Windows Server 2012 以降の OS バージョンの IIS (IIS 8.0 以降) にて、カスタムの ISAPI 拡張 (ハンドラー) をワイルドカード マッピングを利用して動作させたい場合に、</summary>
      
    
    
    
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="ASP.NET" scheme="https://microsoft.github.io/jpwebapps/tags/ASP-NET/"/>
    
    <category term="ハンドラーマッピング" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0/"/>
    
  </entry>
  
  <entry>
    <title>Debug Diagnostics Tool (DebugDiag) の取得方法について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/debugdiag/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/debugdiag/</id>
    <published>2021-06-28T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.385Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供しております。<br>今回は Debug Diagnostics Tool (以降 DebugDiag) によりメモリダンプを取得する手順についてご説明いたします。</p><p>※ なお、Debug Diagnostic Tool ツール自体のサポートは私共技術サポートではご提供しておりません。<br>そのため、なお、Debug Diagnostic Tool ツール自体のトラブルシューティングやツールの詳細なご紹介等はご支援できませんことをご了承ください。</p><h2 id="DebugDiag-とは"><a href="#DebugDiag-とは" class="headerlink" title="DebugDiag とは"></a>DebugDiag とは<!-- omit in toc --></h2><p>DebugDiag とはメモリダンプを取得・解析するための強力なツールです。<br>DebugDiag は我々 IIS サポートチームのみならず、別のサポートチームにおいてでも様々なシナリオでダンプを取得し、そのダンプを解析することで日々お客様の問題解決に貢献しております。</p><h3 id="DebugDiag-のメリット"><a href="#DebugDiag-のメリット" class="headerlink" title="DebugDiag のメリット"></a>DebugDiag のメリット<!-- omit in toc --></h3><p>DebugDiag でのダンプ採取のメリットとして、柔軟なタイミングかつ、メモリの領域を指定して取得することが上げられます。</p><p>取得するメモリの領域の指定は以下 2 つが可能です。  </p><ul><li><strong>User Fulldump</strong> : プロセスの全領域を .dmp としてダンプします。サイズは大きいものの詳細な分析が行えます。</li><li><strong>User Minidump</strong> : プロセスの一部領域 を .dmp としてダンプします。サイズは小さいものの、限られた分析しか行なえません。</li></ul><p>なお通常、お問い合わせの調査には、前者の <strong>User Fulldump</strong> の取得をお願いしております。  </p><p>また取得するタイミングについても以下のように柔軟に変更できます。  </p><ul><li>イベントログにアプリケーションの例外コードが記録されたタイミングで取得する</li><li>イベントログに記録された文字列を起点として取得する</li></ul><p>またそれ以外のメリットとして、ログオフした状態であってもバックグラウンドで DebugDiag を実行可能です。</p><h2 id="目次"><a href="#目次" class="headerlink" title="目次 "></a>目次 <!-- omit in toc --></h2><ul><li><a href="#1-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">1. 前提条件</a><ul><li><a href="#1-1-%E4%BA%8B%E5%89%8D%E3%81%AB%E6%BA%96%E5%82%99%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">1.1. 事前に準備が必要なものについて</a></li></ul></li><li><a href="#2-DebugDiag-%E3%81%AE%E5%8F%96%E5%BE%97%E8%A8%AD%E5%AE%9A">2. DebugDiag の取得設定</a><ul><li><a href="#2-1-Enable-Disable-Performance-Logging-%E3%81%AE-%E7%84%A1%E5%8A%B9%E5%8C%96">2.1. Enable Disable Performance Logging の 無効化</a></li><li><a href="#2-2-Rule-Type-%E3%81%A8-Target-Type-%E3%81%AE%E9%81%B8%E6%8A%9E">2.2. Rule Type と Target Type の選択</a></li></ul></li><li><a href="#3-%E5%AF%BE%E8%B1%A1%E3%81%A8%E3%81%AA%E3%82%8B-DebugDiag-%E3%81%AE%E3%82%BF%E3%83%BC%E3%82%B2%E3%83%83%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97-%E3%81%8C-A-specific-IIS-web-application-pool-%E3%81%AE%E5%A0%B4%E5%90%88">3. 対象となる DebugDiag のターゲットタイプ が A specific IIS web application pool の場合</a><ul><li><a href="#3-1-%E3%83%80%E3%83%B3%E3%83%97%E3%81%AE%E5%8F%96%E5%BE%97%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0-%E3%81%8C-First-Chance-%E3%81%AE%E5%A0%B4%E5%90%88">3.1. ダンプの取得タイミング が First Chance の場合</a></li></ul></li><li><a href="#4-%E3%83%80%E3%83%B3%E3%83%97%E7%94%9F%E6%88%90%E5%BE%8C%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%96%E5%BE%97">4. ダンプ生成後ファイルの取得</a></li><li><a href="#5-DebugDiag-%E3%81%AE%E3%82%A2%E3%83%B3%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">5. DebugDiag のアンインストール方法について</a></li><li><a href="#6-DebugDiag-%E3%81%AE%E6%A4%9C%E8%A8%BC%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">6. DebugDiag の検証方法について</a><ul><li><a href="#6-1-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">6.1. 前提条件</a></li><li><a href="#6-2-%E4%BE%8B%E5%A4%96%E3%82%92%E6%84%8F%E5%9B%B3%E7%9A%84%E3%81%AB%E7%99%BA%E7%94%9F%E3%81%95%E3%81%9B%E3%82%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E9%85%8D%E7%BD%AE">6.2. 例外を意図的に発生させるアプリケーションの配置</a></li><li><a href="#6-3-%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">6.3. 確認方法</a></li></ul></li></ul><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h2><h3 id="1-1-事前に準備が必要なものについて"><a href="#1-1-事前に準備が必要なものについて" class="headerlink" title="1.1. 事前に準備が必要なものについて"></a>1.1. 事前に準備が必要なものについて</h3><p>DebugDiag はインストールが必要かつ、フォアグラウンドまたはバックグラウンドで実行するツールになります。</p><p>64bit 版の DebugDiag をインストールします。<br>※ OS が 32bit 版のみ 32bit 版の DebugDiag をインストールしてください。</p><ul><li>64bit 版の DebugDiag : <a href="http://debugdiag.com/">Debug Diagnostic Tool v2 Update 3</a></li><li>32bit 版の DebugDiag : <a href="https://www.microsoft.com/en-us/download/details.aspx?id=49924">Debug Diagnostic Tool v2 Update 2</a></li></ul><p>.msi ファイルをダウンロードできたら、以下の手順でインストールします。</p><ul><li>ダウンロードした .msi ファイルを起動します。  </li><li>起動後、[Next] を押し、ライセンスを承諾します。  </li><li>デフォルトのフォルダパスは C:\Program Files\DebugDiag ですので、それ以外を設定したい場合は [Browse…] から任意のパスに変更します。</li><li>[Next]を押し、[Install] を実行してください。なお<strong>インストールには管理者権限が必要</strong>です。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-23-23-43-07.png" alt="DebugDiag のインストール設定画面の図"></p><p>これで DebugDiag のインストールは終了です。</p><h2 id="2-DebugDiag-の取得設定"><a href="#2-DebugDiag-の取得設定" class="headerlink" title="2. DebugDiag の取得設定"></a>2. DebugDiag の取得設定</h2><ul><li>[すべてのプログラム] - [Debug Diagnostic Tool 2.0] - [Debug Diagnostics Tool 2.0 Collection] を起動します。  </li><li>[Select Rule Type] 画面が自動的に表示された場合、一旦 [キャンセル] ボタンを押してダイアログを閉じます。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-23-23-57-29.png" alt="DebugDiag 2 Collection の起動画面"></p><h3 id="2-1-Enable-Disable-Performance-Logging-の-無効化"><a href="#2-1-Enable-Disable-Performance-Logging-の-無効化" class="headerlink" title="2.1. Enable Disable Performance Logging の 無効化"></a>2.1. Enable Disable Performance Logging の 無効化</h3><ul><li>Debug Diagnostics Tool の [Tools] - [Options And Settings] メニューをクリックします。  </li><li>[Performance log] - [Enable/Disable Performance Logging] にて、[Disable Performance Counter Data Logging] のラジオボタンにチェックがある状態にして、[OK] ボタンを押して閉じます。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-00-06-11.png" alt="Enable-Disable Performance Logging の無効化の設定図"></p><h3 id="2-2-Rule-Type-と-Target-Type-の選択"><a href="#2-2-Rule-Type-と-Target-Type-の選択" class="headerlink" title="2.2. Rule Type と Target Type の選択"></a>2.2. Rule Type と Target Type の選択</h3><p>この辺りから取得する対象により設定方法が変わります。</p><p>弊社から適宜 “&lt;&gt;” 内の設定項目が指定された場合はそちらに従ってください。<br>もし特に指定がない場合や、こちらのブログを参考に DebugDiag の取得を調査している場合は、<br>例に従うことでアクセス違反発生時にダンプを取得する場合の設定手順をお試しいただけます。</p><ul><li>ウィンドウ下部の [Add Rules] ボタンを押します。表示された [Select Rule Type] 画面にて、&lt;対象となる DebugDiag のルールタイプ&gt; を選択し、[次へ] ボタンを押します。  </li><li>次に、[Select Target Type] 画面にて、&lt;対象となる DebugDiag のターゲットタイプ&gt; を選択し、[次へ] をクリックします。  </li></ul><p>※ 例として、アクセス違反発生時にダンプを取得する場合は、</p><ul><li>[Select Rule Type] には [Crash] を選択し、  </li><li>[Select Target Type] には [A specific IIS web application pool] を選択してください。  </li></ul><p>以下の画像のように設定をすることで、 Access Violation による例外発生によるダンプの取得を行います。  </p><!-- [Crash] 以外についてはGUI上の表示も変わってくることから、今回の説明は Crash 後の選択に合わせた形でよいと考える。仮に Crash 以外の選択が必要になった場合は、別記事として分散させることを期待する。別記事じゃなくここの記事にRule Type 自体もヘッダー分けして書くと、非常に長くなりそうなため。Target Type は a specific IIS webapplication pool 以外も選択したことが過去にもあるため、そこは分岐がある想定で目次のヘッダーの深さをターゲットタイプで ## になるように作成する。--><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-00-17-36.png" alt="Rule Type と Target Type の選択画面図"></p><!--仮にここで分岐が起こる場合は、目次を挿入するのも良いとと考える--><h2 id="3-対象となる-DebugDiag-のターゲットタイプ-が-A-specific-IIS-web-application-pool-の場合"><a href="#3-対象となる-DebugDiag-のターゲットタイプ-が-A-specific-IIS-web-application-pool-の場合" class="headerlink" title="3. 対象となる DebugDiag のターゲットタイプ が A specific IIS web application pool の場合"></a>3. 対象となる DebugDiag のターゲットタイプ が A specific IIS web application pool の場合</h2><p>ダンプの取得タイミングにより更に取得方法が分岐します。以下 2 つのうちどちらかのタイミングで取得します。</p><ul><li><strong>First Chance</strong> : 例外が発生したタイミングで取得する設定で、例外処理をしていてアプリケーションがクラッシュしない場合でも取得する</li><li><strong>Second Chance</strong> : 例外が発生し、例外処理がされずにアプリケーションがクラッシュ場合のみ取得する設定で、クラッシュの直前のタイミングで取得する</li></ul><p>弊社より &lt;ダンプの取得タイミング&gt; について設定項目が指定された場合はそちらに従ってください。<br>※ 例として、アクセス違反発生時にダンプを取得する場合は、 &lt;ダンプの取得タイミング&gt; は First Chance を選択してください。  </p><h3 id="3-1-ダンプの取得タイミング-が-First-Chance-の場合"><a href="#3-1-ダンプの取得タイミング-が-First-Chance-の場合" class="headerlink" title="3.1. ダンプの取得タイミング が First Chance の場合"></a>3.1. ダンプの取得タイミング が First Chance の場合</h3><p>First Chance とは、例外発生したタイミングでダンプを取得する方法になります。<br>例えば try/catch による例外処理をしていて、アプリケーションがクラッシュしない場合においても、First Chance により、例外が発生した瞬間にダンプを取得することができます。</p><ul><li>[Advanced Configuration (Optional)] 画面にて [Advanced Settings] -  [Exceptions…] をクリックします。  </li><li>次に、 [First Chance Exception Configuration] - [Add Exception…] をクリックします。  </li><li>次に、 [Configure Exception] 画面にてダンプを生成する例外の条件を設定します。  </li></ul><p>設定条件には以下を入力してください。<br>(&lt;その他の設定&gt; について弊社から特に指示がない場合は無視してください。)</p><ul><li>[Exception Code (hex)] : &lt;First Chance で対象となる例外コード&gt;</li><li>[Action Type] : &lt;First Chance で取得するダンプの領域&gt;</li><li>[Action Limit] : &lt;First Chance で取得するダンプの回数&gt;</li><li>[その他の設定項目] : &lt;First Chance のその他の設定&gt;</li></ul><p>※ 例として、今回ははアクセス違反発生時にダンプを取得する場合の設定条件を紹介します。<br>以下の画像のように設定をすることで、 Access Violation による例外発生によるダンプの取得を行います。</p><ul><li>[Exception Code (hex)] : C0000005 (Access Violation)</li><li>[Action Type] : Full Userdump</li><li>[Action Limit] : 2</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-02-18-47.png" alt="First Chance で Access Violation の設定画面図"></p><ul><li>[Configure Exception] 画面にて [OK] を選択し、  </li><li>[First Chance Exception Configuration] 画面にて [Save &amp; Close] を選択します。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-01-53-13.png" alt="First Chance で設定完了までの設定図"></p><p>こちらで First Chance つまり例外発生時にダンプを取得する設定を完了しました。</p><ul><li>[Advanced Configuration (Optional)] 画面に戻りますので、[次へ] ボタンを押します。  </li><li>[Select Dump Location And Rule Name (Optional)] では、ダンプの出力先やルールの名前を設定できます。  </li><li>&lt;DebugDiag の有効化時期&gt; について弊社から指定がない場合は、 [Rule Completed] - [Activate the rule now] を選択し、 [完了] をクリックします。</li></ul><p>※ 例として、今回はアクセス違反発生時にダンプを取得する設定の場合は、画像の通り、[Activate the rule now] を選択し、[完了] をクリックします。</p><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-02-19-43.png" alt="DebugDiag の設定の有効化の設定図1"></p><p>なお別のログ採取ツールのタイミングに応じて DebugDiag も有効化したい場合などは、 </p><ul><li>[Do not activate the rule at this time] を選択し、  </li><li>別途 DebugDiag を有効化するタイミングで当該の作成したルールを選び [右クリック] から [Activate Rule] を実行してください。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-02-25-05.png" alt="DebugDiag の設定の有効化の設定図2"></p><h2 id="4-ダンプ生成後ファイルの取得"><a href="#4-ダンプ生成後ファイルの取得" class="headerlink" title="4. ダンプ生成後ファイルの取得"></a>4. ダンプ生成後ファイルの取得</h2><p>設定を完了後、現象の再現を待ちます。<br>事象が発生した場合、出力先に設定した箇所にダンプ ファイル (拡張子 .dmp) が出力されます。そちらをアップロードしてください。</p><h2 id="5-DebugDiag-のアンインストール方法について"><a href="#5-DebugDiag-のアンインストール方法について" class="headerlink" title="5. DebugDiag のアンインストール方法について"></a>5. DebugDiag のアンインストール方法について</h2><p>DebugDiag 自体を削除する場合は、有効化したルールすべてを削除します。  </p><ul><li>コントロールパネルを開き、[プログラムのアンインストールまたは変更] を開きます。  </li><li>DebugDiag のアプリケーションを選択し、 [アンインストール] を実行してください。</li></ul><p><img src="/jpwebapps/web-apps/debugdiag/debugdiag_2021-05-24-02-34-14.png" alt="DebugDiag のアンインストールの画面図"></p><h2 id="6-DebugDiag-の検証方法について"><a href="#6-DebugDiag-の検証方法について" class="headerlink" title="6. DebugDiag の検証方法について"></a>6. DebugDiag の検証方法について</h2><h3 id="6-1-前提条件"><a href="#6-1-前提条件" class="headerlink" title="6.1. 前提条件"></a>6.1. 前提条件</h3><ul><li>ASP.NET が実行できる環境をご用意ください。</li></ul><h3 id="6-2-例外を意図的に発生させるアプリケーションの配置"><a href="#6-2-例外を意図的に発生させるアプリケーションの配置" class="headerlink" title="6.2. 例外を意図的に発生させるアプリケーションの配置"></a>6.2. 例外を意図的に発生させるアプリケーションの配置</h3><ul><li>以下のコードを .aspx という拡張子で保存して IIS 上の任意のサイトに配置します。</li><li>コード中の &lt;検証用の例外コード&gt; には 例外コードを 10 進数で入力します。  </li></ul><p>例えば C0000005 の例外を発生させたい場合は、それを 10 進数で表した 3221225477 を入力します。  </p><p>以下例として、アクセス違反の例外を意図的に発生させます。<br>具体的にはアクセス違反の例外コードである 0xC0000005 を 10 進数表記した 3221225477 を &lt;検証用の例外コード&gt; に指定してください。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Import Namespace=<span class="string">&quot;System.Runtime.InteropServices&quot;</span> %&gt;</span><br><span class="line">&lt;%@ Page language=<span class="string">&quot;C#&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">   &lt;script language=<span class="string">&quot;cs&quot;</span> runat=<span class="string">&quot;server&quot;</span>&gt;</span><br><span class="line">[<span class="built_in">DllImport</span>(<span class="string">&quot;kernel32.dll&quot;</span>)]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="built_in">RaiseException</span>(uint dwExceptionCode, uint dwExceptionFlags,  uint nNumberOfArguments, IntPtr lpArguments);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwEx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RaiseException</span>(&lt;検証用の例外コード&gt;, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">IntPtr</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">(object sender, EventArgs e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.Threading.Thread t = <span class="keyword">new</span> System.Threading.<span class="built_in">Thread</span>(throwEx);</span><br><span class="line">        t.<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form id=<span class="string">&quot;form1&quot;</span> runat=<span class="string">&quot;server&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;asp:Button ID=<span class="string">&quot;Button1&quot;</span> runat=<span class="string">&quot;server&quot;</span> Text=<span class="string">&quot;Button&quot;</span> onclick=<span class="string">&quot;Button1_Click&quot;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以下の項目を右に読み替えていただき、再度 <a href="#2-DebugDiag-%E3%81%AE%E5%8F%96%E5%BE%97%E8%A8%AD%E5%AE%9A">DebugDiag の取得手順</a> に従って、DebugDiag の設定を行います。</p><ul><li>&lt;対象となるアプリケーションプール&gt;: テスト用の上記のコードが配置されたウェブサイトのアプリケーションプール</li><li>&lt;First Chance で対象となる例外コード&gt;: &lt;検証用の例外コード&gt;</li></ul><h3 id="6-3-確認方法"><a href="#6-3-確認方法" class="headerlink" title="6.3. 確認方法"></a>6.3. 確認方法</h3><ul><li>設定を終了後、当該の検証用のアプリケーションにアクセスして、[Button] をクリックします。  </li><li>ダンプの出力先として設定したフォルダに、メモリダンプが出力されているかどうかをご確認ください。</li></ul><!--## DebugDiag についての FAQDebugDiag についてよくいただくご質問について以下におまとめしております。- [DebugDiag についての Q&A][DebugDiag についての Q&A]  以上の Q&A を確認したもののご不明点が解決しない場合は、  私共サポートまでお問い合わせいただけますと大変幸いです。 DebugDiag FAQ のネタについて- DebugDiag 取得時にシステムに与える影響について- DebugDiag の解析方法？- DebugDiag の検証方法はこっちじゃなくていいのかな-->]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供しております。&lt;br&gt;今回は Debug Diagnostics Tool (以降 DebugDiag) によりメモリダ</summary>
      
    
    
    
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="DebugDiag" scheme="https://microsoft.github.io/jpwebapps/tags/DebugDiag/"/>
    
  </entry>
  
  <entry>
    <title>失敗した要求トレース (FREB) の取得方法について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/freb/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/freb/</id>
    <published>2021-05-26T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.389Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。<br>今回は 失敗した要求トレース 通称 FREB の取得手順についてご説明します。</p><h2 id="FREB-とは"><a href="#FREB-とは" class="headerlink" title="FREB とは "></a>FREB とは <!-- omit in toc --></h2><p>FREB はウェブ リクエストにウェブサーバーがどのように応答したか、その処理過程を .xml 形式のログに出力するモジュールです。<br>リクエストの応答に問題があった場合、FREB のログを確認することで問題の調査を行えます。  </p><p>ログ出力の条件は柔軟に設定することができます。40X や 50X などの応答が起きた時、もしくはリクエストの処理時間が一定時間を超えた時など、状況に合わせた設定可能です。</p><p>FREB の詳しい説明は <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/cc730608(v=ws.10)#failed-request-tracing-rules">Monitor Activity on a Web Server (IIS 7)</a> をご確認ください。</p><p>なお注意点として [トレース] 機能をサーバーの機能としてインストールしていない場合、インストール時に IIS サービスの再起動が発生します。<br>再起動時に、IIS サーバーが処理している既存のリクエストがエラーになる可能性もあるためご注意ください。<br>慎重を期す場合は、メンテナンス時間などにおいて設定することを推奨します。  </p><h2 id="目次"><a href="#目次" class="headerlink" title="目次 "></a>目次 <!-- omit in toc --></h2><ul><li><a href="#1-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">1. 前提条件</a><ul><li><a href="#11-%E4%BA%8B%E5%89%8D%E3%81%AB%E6%BA%96%E5%82%99%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">1.1. 事前に準備が必要なものについて</a></li></ul></li><li><a href="#2-FREB-%E3%81%AE%E8%A8%AD%E5%AE%9A%E6%89%8B%E9%A0%86">2. FREB の設定手順</a><ul><li><a href="#21-FREB-%E3%81%AE%E6%9C%89%E5%8A%B9%E5%8C%96">2.1. FREB の有効化</a></li><li><a href="#22-FREB-%E3%81%AE%E8%A6%8F%E5%89%87%E4%BD%9C%E6%88%90">2.2. FREB の規則作成</a></li></ul></li><li><a href="#3-FREB-%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%81%AE%E5%89%8A%E9%99%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">3. FREB の設定の削除について</a></li><li><a href="#4-FREB-%E3%81%AE%E6%A4%9C%E8%A8%BC%E6%89%8B%E9%A0%86%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4. FREB の検証手順について</a><ul><li><a href="#41-%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90">4.1. ウェブサイトの作成</a></li><li><a href="#42-%E5%A4%B1%E6%95%97%E3%81%97%E3%81%9F%E8%A6%81%E6%B1%82%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9%E3%81%AE%E8%A8%AD%E5%AE%9A">4.2. 失敗した要求トレースの設定</a></li><li><a href="#43-%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E5%89%8A%E9%99%A4">4.3. ウェブサイトの削除</a></li></ul></li></ul><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h2><h3 id="1-1-事前に準備が必要なものについて"><a href="#1-1-事前に準備が必要なものについて" class="headerlink" title="1.1. 事前に準備が必要なものについて"></a>1.1. 事前に準備が必要なものについて</h3><p>IIS Manager を起動し、中央のアイコンで、[IIS] - [失敗した要求トレース] が存在することを確認します。</p><p>もしこちらが存在しない場合は、失敗した要求トレース (FREB) を記録するモジュールが存在しないため、<br>サーバー マネージャーの役割サービスの追加で、[Web サーバー] - [状態と診断] - [トレース] をインストールします。<br><strong>インストールの際は、IIS の再起動が発生しますのでご注意ください。</strong></p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-23-05-29-05.png" alt="FREB のインストールが必要な場合についての説明図"></p><h2 id="2-FREB-の設定手順"><a href="#2-FREB-の設定手順" class="headerlink" title="2. FREB の設定手順"></a>2. FREB の設定手順</h2><h3 id="2-1-FREB-の有効化"><a href="#2-1-FREB-の有効化" class="headerlink" title="2.1. FREB の有効化"></a>2.1. FREB の有効化</h3><p>IIS マネージャーを起動し、[Web サイト] から現象が発生している &lt;対象となるウェブサイト&gt; を選択します。  </p><p>[操作] - [構成] - [失敗した要求トレース] をクリックします。  </p><p>[失敗した要求のトレースが、この Web サイトに対して有効になっていません。] という警告が表示される場合はクリックしてログを有効にします。</p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-23-22-37-02.png" alt="FREBの有効化の説明図1"></p><p>[操作] ウィンドウの [サイトのトレースの編集] をクリックし、[有効にする] にチェックがあることを確認してください。</p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-18-02-00-38.png" alt="FREBの有効化の説明図2"></p><h3 id="2-2-FREB-の規則作成"><a href="#2-2-FREB-の規則作成" class="headerlink" title="2.2. FREB の規則作成"></a>2.2. FREB の規則作成</h3><p>[失敗した要求トレースの規則] - [操作] - [追加] をクリックします。</p><p>[トレースするコンテンツの指定] で、&lt;トレースするコンテンツ&gt;、<br>[トレース条件の定義] で、&lt;トレース条件の定義&gt;、<br>[トレース プロバイダーの選択] で、 &lt;トレースプロバイダー&gt; を設定し [終了] をクリックします。</p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-20-01-17-01.png" alt="FREB の規則作成手順図"></p><p>[トレース条件の定義] を [状態コード]、[所要時間] それぞれでチェックを有効化した場合、条件は AND ではなく OR として判断されます。<br>つまり、いずれかの条件に合致した場合に FREB によりログが出力されますので、ご注意ください。</p><p>[トレース条件の定義] の詳細については、<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/cc725948(v=ws.10)">Create a Tracing Rule for Failed Requests (IIS 7)</a> をご確認ください。</p><h2 id="3-FREB-の設定の削除について"><a href="#3-FREB-の設定の削除について" class="headerlink" title="3. FREB の設定の削除について"></a>3. FREB の設定の削除について</h2><p>FREB自体を無効化する場合は、<br>&lt;対象となるウェブサイト&gt; の 失敗した要求トレースの規則 を開き、作成した規則を選択し、削除 を押してください。</p><h2 id="4-FREB-の検証手順について"><a href="#4-FREB-の検証手順について" class="headerlink" title="4. FREB の検証手順について"></a>4. FREB の検証手順について</h2><h3 id="4-1-ウェブサイトの作成"><a href="#4-1-ウェブサイトの作成" class="headerlink" title="4.1. ウェブサイトの作成"></a>4.1. ウェブサイトの作成</h3><p>IIS 上にウェブサイトを作成し、ウェブ アクセスした際に 200 レスポンスが返されることを契機として、メモリダンプを取得します。</p><p>以下の画像のように、ウェブサイトを作成し、メモ帳などで作成した iisstart.htm を C:\inetpub\wwwroot 以下に作成します。問題なくアクセスできることを確認します。</p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-20-00-02-46.png" alt="IIS 上でのウェブサイトの作成手順説明図"></p><h3 id="4-2-失敗した要求トレースの設定"><a href="#4-2-失敗した要求トレースの設定" class="headerlink" title="4.2. 失敗した要求トレースの設定"></a>4.2. 失敗した要求トレースの設定</h3><p>トレース条件の定義として、200 を指定し、サイトにアクセスすることで、FREB の出力先に .xml 形式の出力があるかを確認します。</p><p><img src="/jpwebapps/web-apps/freb/freb_2021-05-20-00-00-59.png" alt="失敗した要求トレースの出力の確認図"></p><h3 id="4-3-ウェブサイトの削除"><a href="#4-3-ウェブサイトの削除" class="headerlink" title="4.3. ウェブサイトの削除"></a>4.3. ウェブサイトの削除</h3><p>IIS マネージャー より [サイト] を開き、検証用に作成したサイトを削除してください。</p><!-- ## 4. FREB の FAQ についてこちらは [失敗した要求トレース (FREB) でよくいただくご質問について](https://microsoft.github.io/jpwebapps/web-apps/freb-faq/) をご確認ください。以上の Q&A を確認したもののご不明点が解決しない場合は、私共サポートまでお問い合わせいただけますと大変幸いです。-->]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。&lt;br&gt;今回は 失敗した要求トレース 通称 FREB の取得手順についてご説明します。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="FREB" scheme="https://microsoft.github.io/jpwebapps/tags/FREB/"/>
    
  </entry>
  
  <entry>
    <title>失敗した要求トレースを契機とするメモリダンプ (FREBDump) のよくあるご質問</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/frebdump-faq/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/frebdump-faq/</id>
    <published>2021-05-26T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.392Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。 </p><p>FREBDump について、今回はよくいただくご質問についてまとめました。</p><h2 id="目次"><a href="#目次" class="headerlink" title="目次 "></a>目次 <!-- omit in toc --></h2><ul><li><a href="#FREBDump-%E3%81%AE%E6%A4%9C%E8%A8%BC%E6%89%8B%E9%A0%86%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">FREBDump の検証手順について</a></li><li><a href="#FREB-%E3%81%AE-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9%E3%81%99%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E6%8C%87%E5%AE%9A-%E3%81%A7%E3%81%AE-%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0-%E3%81%AE%E6%B3%A8%E6%84%8F%E7%82%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">FREB の [トレースするコンテンツの指定] での [カスタム] の注意点について</a></li></ul><h2 id="FREBDump-の検証手順について"><a href="#FREBDump-の検証手順について" class="headerlink" title="FREBDump の検証手順について"></a>FREBDump の検証手順について</h2><p>以下簡易ではありますが、FREBDump が問題なく取得できるか確認するための取得手順をおまとめいたしました。<br>事前検証が必要な場合は、こちらによりメモリダンプが生成されているかご確認いただけますと幸いです。</p><h3 id="ウェブサイトの作成"><a href="#ウェブサイトの作成" class="headerlink" title="ウェブサイトの作成"></a>ウェブサイトの作成<!-- omit in toc --></h3><p>IIS 上にウェブサイトを作成し、ウェブ アクセスした際に 200 レスポンスが返されることを契機として、メモリダンプを取得します。</p><p>以下の画像のように、ウェブサイトを作成し、メモ帳などで作成した iisstart.htm を C:\inetpub\wwwroot 以下に作成します。問題なくアクセスできることを確認します。</p><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-00-02-46.png" alt="IIS 上でのウェブサイトの作成手順説明図"></p><h3 id="失敗した要求トレースの設定"><a href="#失敗した要求トレースの設定" class="headerlink" title="失敗した要求トレースの設定"></a>失敗した要求トレースの設定<!-- omit in toc --></h3><p>トレース条件の定義として、200 を指定します。<br>サイトにアクセスすることで、FREB の出力先に .xml 形式の出力があるかを確認します。</p><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-00-00-59.png" alt="失敗した要求トレースの出力の確認図"></p><h3 id="構成エディター-での-ProcDump-の設定"><a href="#構成エディター-での-ProcDump-の設定" class="headerlink" title="構成エディター での ProcDump の設定"></a>構成エディター での ProcDump の設定<!-- omit in toc --></h3><p>画像を参考に、サーバーにおいて構成エディタにて customActionEnabled の有効化を行います。<br>その後、サイトの構成エディターにおいて、[customActionExe]、[customeActionParams]、[customActionTriggerLimit] を以下の値で設定します。</p><ul><li>[customActionExe] : C:\Procdump\procdump.exe などのインストールした .exe のパス</li><li>[customActionParams] : -accepteula -ma -s 30 -n 2 %1% &lt;任意のダンプの出力先のフォルダ&gt;</li><li>[customActionTriggerLimit] : 1</li></ul><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-00-20-13.png"></p><h3 id="ダンプ生成の確認"><a href="#ダンプ生成の確認" class="headerlink" title="ダンプ生成の確認"></a>ダンプ生成の確認<!-- omit in toc --></h3><p>作成したサイトにウェブ アクセスを行います。<br>200 レスポンスが返答されたことを契機として FREBDump が取得されます。<br>FREB、 ProcDump の出力先に ファイルが生成されていることをご確認ください。</p><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-00-22-28.png"></p><h2 id="FREB-の-トレースするコンテンツの指定-での-カスタム-の注意点について"><a href="#FREB-の-トレースするコンテンツの指定-での-カスタム-の注意点について" class="headerlink" title="FREB の [トレースするコンテンツの指定] での [カスタム] の注意点について"></a>FREB の [トレースするコンテンツの指定] での [カスタム] の注意点について</h2><p>カスタムにてパスを指定した際に、[既定のドキュメント] の設定によりサイトアクセスが “/“ ディレクトリでアクセスできる場合、FREB がうまく発火しない場合がございます。</p><p>例えば、<a href="http://localhost/iisstart.htm">http://localhost/iisstart.htm</a> がフルパスになるような iisstart.htm のファイルをサイトに配置します。</p><p>既定の設定では、[既定のドキュメント] に iisstart.htm が存在するため、 https://&lt;サイト名/&gt; でアクセスが可能です。</p><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-12-53-09.png"></p><p>この場合、[カスタム] のパスに iisstart.htm や /iisstart.htm を設定していると、 “/“ などのディレクトリアクセスの時は FREB は発火しません。</p><p><img src="/jpwebapps/web-apps/frebdump-faq/frebdump-faq_2021-05-20-13-20-16.png"></p><p>[カスタム] の設定は FREB を仕掛けたいアプリケーションを制限する場合に有用な設定ですが、そのアプリケーションやウェブページが [既定のドキュメント] に存在する場合は以上の注意が必要になります。</p><!-- - FREBDump の customActionExe, customeActionParam, customeActionTrigger の説明- ProcDump のオプションについて-->]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。 &lt;/p&gt;
&lt;p&gt;FREBDump について、今回はよくいただくご質問についてまとめました。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="FREBDump" scheme="https://microsoft.github.io/jpwebapps/tags/FREBDump/"/>
    
    <category term="FAQ" scheme="https://microsoft.github.io/jpwebapps/tags/FAQ/"/>
    
  </entry>
  
  <entry>
    <title>失敗した要求トレースを契機とするメモリダンプ (FREBDump) の取得方法 について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/frebdump/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/frebdump/</id>
    <published>2021-05-26T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.394Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。<br>今回は IIS のワーカープロセス (w3wp.exe) のメモリダンプを取得する手法の一つ、FREBDump の手順についてご説明します。</p><h2 id="FREBDump-とは"><a href="#FREBDump-とは" class="headerlink" title="FREBDump とは "></a>FREBDump とは <!-- omit in toc --></h2><p>FREBDump とは、失敗した要求トレース (通称: FREB) を契機として ProcDump を実行することを指します。</p><p>(なお FREBDump は正式名称ではございません。失敗した要求トレース が 英語で Failed Request Event Buffering (FREB) と呼ばれること、ProcDump の Dump から FREBDump と呼称しております。)</p><p>このログ取得のポイントは FREB の発火点によって ProcDump を制御するところにあります。</p><h2 id="FREBDump-のメリット"><a href="#FREBDump-のメリット" class="headerlink" title="FREBDump のメリット "></a>FREBDump のメリット <!-- omit in toc --></h2><p>FREBDump でのダンプ採取のメリットは、ProcDump よりも柔軟なタイミングでのダンプの取得ができることです。<br>例えば以下は ProcDump では難しいですが、 FREBDump では可能になります。</p><ol><li>IIS サーバーが受け取ったリクエストで特定の時間以上になった場合にダンプを取る</li><li>40X や 50X など、特定のエラーレスポンスで応答されたタイミングでダンプを取る</li></ol><p>例えば、お客様から IIS サーバーが不定期にスローダウンし、リクエストのレスポンスが遅くなるといったお問い合わせをいただくことがございます。<br>このような場合は 1) のように特定の時間でダンプを生成するように設定することで調査をすることができます。</p><h2 id="目次"><a href="#目次" class="headerlink" title="目次 "></a>目次 <!-- omit in toc --></h2><ul><li><a href="#1-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">1. 前提条件</a><ul><li><a href="#11-%E4%BA%8B%E5%89%8D%E3%81%AB%E6%BA%96%E5%82%99%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">1.1. 事前に準備が必要なものについて</a></li></ul></li><li><a href="#2-FREBDump-%E3%81%AE%E8%A8%AD%E5%AE%9A%E6%89%8B%E9%A0%86">2. FREBDump の設定手順</a><ul><li><a href="#21-FREB-%E3%81%AE%E6%9C%89%E5%8A%B9%E5%8C%96">2.1. FREB の有効化</a></li><li><a href="#22-FREB-%E3%81%AE%E8%A6%8F%E5%89%87%E4%BD%9C%E6%88%90">2.2. FREB の規則作成</a></li><li><a href="#23-ProcDump-%E3%81%AE%E8%A8%AD%E5%AE%9A">2.3. ProcDump の設定</a><ul><li><a href="#231-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%A7%E3%81%AE-customActionEnable-%E3%81%AE%E8%A8%AD%E5%AE%9A">2.3.1. サーバーでの customActionEnable の設定</a></li><li><a href="#232-%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E5%81%B4%E3%81%A7%E3%81%AE-customActionExe-%E3%81%AA%E3%81%A9%E3%81%AE%E8%A8%AD%E5%AE%9A">2.3.2. ウェブサイト側での customActionExe などの設定</a></li></ul></li><li><a href="#24-FREBDump-%E3%81%AE%E3%82%A2%E3%83%B3%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">2.4. FREBDump のアンインストール方法について</a></li><li><a href="#25-FREB-%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%81%AE%E5%89%8A%E9%99%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">2.5. FREB の設定の削除について</a></li><li><a href="#26-ProcDump-%E3%81%AE%E5%89%8A%E9%99%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">2.6. ProcDump の削除について</a></li></ul></li><li><a href="#3-FREBDump-%E3%81%AE%E6%A4%9C%E8%A8%BC%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">3. FREBDump の検証方法について</a></li><li><a href="#4-FREBDump-%E3%81%AE-FAQ-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4. FREBDump の FAQ について</a></li></ul><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h2><h3 id="1-1-事前に準備が必要なものについて"><a href="#1-1-事前に準備が必要なものについて" class="headerlink" title="1.1. 事前に準備が必要なものについて"></a>1.1. 事前に準備が必要なものについて</h3><p>FREBDump の取得のためには以下がインストールされている必要がございます。</p><ul><li>失敗した要求トレース (FREB) がインストールされていること</li><li>ProcDump がインストールされていること</li></ul><p>IIS Manager を起動し、中央のアイコンで、[IIS] - [失敗した要求トレース] が存在することを確認します。</p><p>もしこちらが存在しない場合は、失敗した要求トレース (FREB) のモジュールが存在しません。<br>その場合、サーバー マネージャーの役割サービスの追加で、[Web サーバー] - [状態と診断] - [トレース] をインストールします。<strong>インストールの際は、IIS の再起動が発生しますのでご注意ください。</strong></p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-22-38-58.png" alt="FREB のインストールが必要な場合について"></p><h2 id="2-FREBDump-の設定手順"><a href="#2-FREBDump-の設定手順" class="headerlink" title="2. FREBDump の設定手順"></a>2. FREBDump の設定手順</h2><h3 id="2-1-FREB-の有効化"><a href="#2-1-FREB-の有効化" class="headerlink" title="2.1. FREB の有効化"></a>2.1. FREB の有効化</h3><p>IIS マネージャーを起動し、[Web サイト] から現象が発生している &lt;対象となるウェブサイト&gt; を選択します。  </p><p>[操作] - [構成] - [失敗した要求トレース] をクリックします。  </p><p>[失敗した要求のトレースが、この Web サイトに対して有効になっていません。] という警告が表示される場合は、クリックしてログを有効にします。</p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-00-53-50.png" alt="FREBの有効化の説明図1"></p><p>[操作] ウィンドウの [サイトのトレースの編集] をクリックし、[有効にする] にチェックがあることを確認してください。</p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-18-02-00-38.png" alt="FREBの有効化の説明図2"></p><h3 id="2-2-FREB-の規則作成"><a href="#2-2-FREB-の規則作成" class="headerlink" title="2.2. FREB の規則作成"></a>2.2. FREB の規則作成</h3><p>[失敗した要求トレースの規則] - [操作] - [追加] をクリックします。</p><p>[トレースするコンテンツの指定] で、&lt;トレースするコンテンツ&gt;、<br>[トレース条件の定義] で、&lt;トレース条件の定義&gt;、<br>[トレース プロバイダーの選択] で、 &lt;トレースプロバイダー&gt; を設定し [終了] をクリックします。</p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-01-17-01.png" alt="FREB の規則作成手順図"></p><h3 id="2-3-ProcDump-の設定"><a href="#2-3-ProcDump-の設定" class="headerlink" title="2.3. ProcDump の設定"></a>2.3. ProcDump の設定</h3><h4 id="2-3-1-サーバーでの-customActionEnable-の設定"><a href="#2-3-1-サーバーでの-customActionEnable-の設定" class="headerlink" title="2.3.1. サーバーでの customActionEnable の設定"></a>2.3.1. サーバーでの customActionEnable の設定</h4><p>IIS マネージャーの[接続] ウィンドウで、最上位に存在するサーバーの [構成エディター] をダブルクリックします。<br>セクションで system.applicationHost/sites を選択します。</p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-20-55-37.png" alt="構成エディターの選択図"></p><p>(コレクション) の行を選択し、右側にある […] ボタンをクリックします。<br>[コレクション エディター] 画面で、&lt;対象となるウェブサイト&gt; を選択します。<br>プロパティより、[traceFailedRequestsLogging] を展開し、以下を設定します。</p><ul><li>[customActionsEnabled] : True  </li><li>[maxLogFileSizeKB] : 1024</li></ul><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-20-57-52.png" alt="サーバー側構成エディターの設定図"></p><p>コレクション エディター ウィンドウを閉じ、適用します。</p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-21-32-52.png" alt="構成エディターの適用図"></p><h4 id="2-3-2-ウェブサイト側での-customActionExe-などの設定"><a href="#2-3-2-ウェブサイト側での-customActionExe-などの設定" class="headerlink" title="2.3.2. ウェブサイト側での customActionExe などの設定"></a>2.3.2. ウェブサイト側での customActionExe などの設定</h4><p>サーバーを選択しましたが、次は &lt;対象となるウェブサイト&gt; を選択して、<br>サイトに存在する構成エディターを開きます。<br>[場所] が &lt;対象となるウェブサイト&gt; Web.config であるを確認してください。<br>[セクション] で  system.webServer/tracing/traceFailedRequests を選択します。  </p><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-26-22-08-45.png" alt="サイトの構成エディターの選択図"></p><p>(コレクション) の行を選択し、右側にある […] ボタンをクリックします。<br>[コレクション エディター] 画面で、path が * となっている行を選択し、<br>[プロパティ] ウィンドウの各項目に ProcDump の設定を行います。</p><p>以下それぞれを入力してください。</p><ul><li>[customActionExe] : &lt;インストールした ProcDump のパス&gt;</li><li>[customActionParams] : &lt;ProcDump の引数&gt;</li><li>[customActionTriggerLimit] : &lt;customActionExe の試行回数&gt;</li></ul><p>※弊社から特に指示がない場合は以下の通りに行ってください。</p><ul><li>[customActionExe] : &lt;C:\Procdump\procdump.exe などのインストールした .exe のパス&gt;</li><li>[customActionParams] : -accepteula -ma -s 30 -n 2 %1% &lt;C:\ProcDump\output などのダンプファイル保存場所&gt;</li><li>[customActionTriggerLimit] : 2</li></ul><p><img src="/jpwebapps/web-apps/frebdump/frebdump_2021-05-20-22-30-14.png" alt="構成エディターによる ProcDump の設定図"></p><p>コレクション エディター ウィンドウを閉じます。<br>[操作] ウィンドウで、[適用] を選択します。</p><p>以上で設定は終了です。</p><h3 id="2-4-FREBDump-のアンインストール方法について"><a href="#2-4-FREBDump-のアンインストール方法について" class="headerlink" title="2.4. FREBDump のアンインストール方法について"></a>2.4. FREBDump のアンインストール方法について</h3><p>&lt;対象となるウェブサイト&gt; の構成エディタで設定した以下3つの値を削除します。</p><ul><li>customActionExe</li><li>customActionParams</li><li>customActionTriggerLimit</li></ul><p>サーバーの構成エディタで設定した以下の設定を変更します</p><ul><li>customActionEnabled = True の設定を False</li></ul><h3 id="2-5-FREB-の設定の削除について"><a href="#2-5-FREB-の設定の削除について" class="headerlink" title="2.5. FREB の設定の削除について"></a>2.5. FREB の設定の削除について</h3><p>FREB 自体を無効化する場合は、<br>&lt;対象となるウェブサイト&gt; の 失敗した要求トレースの規則 を開き、作成した規則を選択し、削除 を押してください。</p><h3 id="2-6-ProcDump-の削除について"><a href="#2-6-ProcDump-の削除について" class="headerlink" title="2.6. ProcDump の削除について"></a>2.6. ProcDump の削除について</h3><p>ProcDump はインストールしたフォルダごと削除いただくことでアンインストールできます。</p><h2 id="3-FREBDump-の検証方法について"><a href="#3-FREBDump-の検証方法について" class="headerlink" title="3. FREBDump の検証方法について"></a>3. FREBDump の検証方法について</h2><p>こちらは <a href="https://microsoft.github.io/jpwebapps/web-apps/frebdump-faq/">失敗した要求トレースを契機とするメモリダンプ (FREBDump) でよくいただくご質問について</a> をご確認ください。</p><h2 id="4-FREBDump-の-FAQ-について"><a href="#4-FREBDump-の-FAQ-について" class="headerlink" title="4. FREBDump の FAQ について"></a>4. FREBDump の FAQ について</h2><p>こちらは <a href="https://microsoft.github.io/jpwebapps/web-apps/frebdump-faq/">失敗した要求トレースを契機とするメモリダンプ (FREBDump) でよくいただくご質問について</a> をご確認ください。</p><!-- また今回利用した 失敗した要求トレース(FREB)、ProcDump についての Q&A も合わせてご確認いただけますと幸いです。- [失敗した要求トレース(FREB) についての Q&A][失敗した要求トレース(FREB) についてのQ&A]- [ProcDump についての Q&A][ProcDump についての Q&A]--><p>以上の Q&amp;A を確認したもののご不明点が解決しない場合は、私共サポートまでお問い合わせいただけますと大変幸いです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てる内容をご提供させていただきます。&lt;br&gt;今回は IIS のワーカープロセス (w3wp.exe) のメモリダンプを取得する手法の一つ</summary>
      
    
    
    
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="FREBDump" scheme="https://microsoft.github.io/jpwebapps/tags/FREBDump/"/>
    
  </entry>
  
  <entry>
    <title>異なるドメイン間で仮想ディレクトリを作成する場合の注意点</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/VirtualDirectory/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/VirtualDirectory/</id>
    <published>2021-04-18T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.384Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです。</p><p>IIS 上で仮想ディレクトリを作成することがありますが、信頼関係がない異なるドメイン間で仮想ディレクトリを作成しようとした場合、仮想ディレクトリの作成に失敗します。具体的には仮想ディレクトリを作成する際に別ドメインの資格情報を記入するタイミングでエラーが発生します。</p><p> <img src="/jpwebapps/web-apps/VirtualDirectory/pic.png" alt="IIS仮想ディレクトリ図"></p><p>この現象の再現方法は以下の通りになります。</p><ol><li>ドメインAに参加しているマシン上にあるIISマネージャーを起動します。</li><li>サイト用の仮想ディレクトリを追加します。</li><li>「接続」方法として「特定ユーザー」を選択し、資格情報の設定を行います。</li><li>「資格情報の設定」画面に信頼関係を結んでいないドメイン Bのユーザー名とパスワードを入力します。</li><li>「資格情報の設定」画面のOKボタンを実行すると、「指定したパスワードは無効です。新しいパスワードを入力してください。」とエラーが表示されます。</li></ol><p>資格情報を記入した後、設定を完了するタイミングで行われる IIS の内部処理で、指定したユーザー情報を利用して認証を試みます。「資格情報の設定」画面に入力したドメイン名、ユーザー名、パスワードをもとに認証を試みますが、信頼関係のないドメインのユーザーの資格情報ではログインできないため、認証に失敗し、該当のエラーが記録されます。</p><p>この挙動は IIS の想定された動作になります。そのため、異なるドメイン間で仮想ディレクトリを作成いただく場合は、事前にドメイン間で信頼関係を築いていただく必要があります。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです。&lt;/p&gt;
&lt;p&gt;IIS 上で仮想ディレクトリを作成することがありますが、信頼関係がない異なるドメイン間で仮想ディレクトリを作成しようとした場合、仮想ディレクトリの作成に失敗します。具体的には仮想ディレクトリを作成する際に別ドメインの</summary>
      
    
    
    
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="Virtual Directory" scheme="https://microsoft.github.io/jpwebapps/tags/Virtual-Directory/"/>
    
  </entry>
  
  <entry>
    <title>gRPC で動く CLI チャットアプリを ASP.NET Core で実装してみよう！</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/GrpcChatOnAspNetCore/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/GrpcChatOnAspNetCore/</id>
    <published>2020-09-14T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.379Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。<br>Developer Support Internet チーム にてインターンをしている尾崎耀一と申します！</p><p>今回は ASP.NET Core を用いて、 gRPC で動く CLI （コマンドライン）でチャットができるアプリを作る方法を紹介します。<br>本記事を通じて、 ASP.NET Core を用いた gRPC サービスの開発が簡単にできることがわかると思います。<br>皆様の開発の一助になると幸いです。</p><p>まずはチャット アプリを作る前に ASP.NET Core についてご紹介します。</p><hr><h2 id="ASP-NET-Core-について"><a href="#ASP-NET-Core-について" class="headerlink" title="ASP.NET Core について"></a>ASP.NET Core について</h2><p>ASP.NET Core はクロスプラットフォームで動作するウェブアプリケーションフレームワークです。</p><p>ASP.NET Core を用いることで簡単にウェブアプリを開発することができます。加えて、 ASP.NET Core はクロスプラットフォームに対応しているので、 Windows/macOS/Linux 上で開発・実行することができます。</p><p>ASP.NET Core はオープンソースで開発が進められており、 ASP.NET Core コミュニティーは大きく成長しています。</p><p>ASP.NET Core はモダンなウェブ開発をフレームワークとしてサポートしています。テストが容易に実行できるようなアーキテクチャを採用しており、クラウドへのデプロイなども想定し Visual Studio などのエディタも用意されています。</p><p>また、最新の技術にも対応しています。 例えば、gRPC によるリモート プロシージャ コールのサポートや <a href="https://webassembly.org/">WebAssemby</a> によって SAP（Single Page Application）を C# で開発する <a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> というフレームワークもサポートしています。</p><p>公式ドキュメントにもあるように、ASP.NET Core には次のような利点があります。</p><blockquote><ul><li>Web UI と Web API を構築するプロセスの統一。</li><li>テストの容易性を考慮したアーキテクチャ。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/razor-pages/?view=aspnetcore-3.1">Razor Pages</a> により、ページ コーディングに重点を置いたシナリオがより簡略化され、その生産性が高められます。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> により、ブラウザー内で JavaScript と共に C# を使用できます。 すべて .NET で記述された、サーバー側とクライアント側アプリのロジックを共有します。</li><li>Windows、macOS、Linux 上で開発および実行できること。</li><li>オープン ソースで<a href="https://live.asp.net/">コミュニティ重視</a>。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1">最新のクライアント側フレームワーク</a>と開発ワークフローの統合。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/grpc/?view=aspnetcore-3.1">gRPC</a> を使用したリモート プロシージャ コール (RPC) サービスのホストのサポート。</li><li>クラウド対応で環境ベースの<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1">構成システム</a>。</li><li>組み込まれている<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">依存性の注入</a>。</li><li>軽量で<a href="https://github.com/aspnet/benchmarks">高パフォーマンス</a>のモジュール化された HTTP 要求パイプライン。</li><li>次がホストする機能です。<ul><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1">Kestrel</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/iis/?view=aspnetcore-3.1">IIS</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-3.1">HTTP.sys</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-3.1">Nginx</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/linux-apache?view=aspnetcore-3.1">Apache</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/docker/?view=aspnetcore-3.1">Docker</a></li></ul></li><li><a href="https://docs.microsoft.com/ja-jp/dotnet/standard/choosing-core-framework-server#side-by-side-net-versions-per-application-level">side-by-side でのバージョン管理</a>。</li><li>最新の Web 開発を簡単にするツール。<blockquote><p>ASP.NET Core 公式ドキュメントより抜粋</p></blockquote></li></ul></blockquote><p>参考：<a href="https://docs.microsoft.com/ja-jp/aspnet/core/?view=aspnetcore-3.1">ASP.NET Core 公式ドキュメント</a><br>参考：<a href="https://docs.microsoft.com/ja-jp/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1">ASP.NET Coreについて</a></p><h2 id="gRPC-について"><a href="#gRPC-について" class="headerlink" title="gRPC について"></a>gRPC について</h2><p>次に、 gRPC についてご紹介します。</p><p>gRPC は言語に依存しない高性能なリモート プロシージャ コール（RPC）フレームワークです。</p><p>gRPC を用いることで、やり取りされるデータのシリアライズ・デシリアライズや通信部分はフレームワーク側がカバーしてくれるため、アプリケーション開発者はプロシージャを呼び出すクライアントと呼び出されるサーバプロシージャのみを実装すれば良いということになります。</p><p>gRPC ではデータのシリアライズに Protocol Buffers をデフォルトでは採用しています。Protocol Buffers はサービス間のインタフェースを定義する言語とそれを書くプログラミング言語のプログラムにコンパイルするツール群を含んでいます。Protocol Buffers では、公開する関数 (リモートプロシージャ) や、やり取りするデータの型を <code>.proto</code> ファイルにて定義し、 <code>.proto</code> ファイルからデータをシリアライズするプログラムのソースコードを自動生成することができ、対応する言語も C++/C#/Go/Java/Python etc… と豊富です。サービス間のインタフェースをコードとして静的に定義することが可能であるため、ソースコードの生成のみならず、ドキュメントの自動生成などもできます。</p><p>また、gRPC には次のような特徴を持ちます。</p><ul><li>Protocol Buffers を内部で用いているので他言語でのサーバ・クライアントの開発が可能です。</li><li>HTTP/2 による通信を行います。ゆえに双方向ストリーミング通信もサポートしています。</li><li>その手軽さと利便性から Netflix などでも採用されており、今後もユースケースの増加が見込まれます。</li></ul><p><img src="/jpwebapps/web-apps/GrpcChatOnAspNetCore/grpc.png" alt="gRPC を利用したサーバ・クライアント間通信の概念図"></p><p>参考：<a href="https://grpc.io/">gRPC 公式サイト</a><br>参考：<a href="https://developers.google.com/protocol-buffers">Protocol Buffers 公式サイト</a></p><h2 id="Hands-on：CLI-Chat-アプリ"><a href="#Hands-on：CLI-Chat-アプリ" class="headerlink" title="Hands-on：CLI Chat アプリ"></a>Hands-on：CLI Chat アプリ</h2><p>今回は gRPC で通信する Chat サーバと Chat クライアントを ASP.NET Core を用いて実装します。さらに gRPC で通信する Chat クライアントを C# とは別の言語（今回は go 言語）で実装し、 gRPC の「プログラミング言語に依存しない」という特徴も確認します。 ASP.NET Core を用いた gRPC サービスの開発が非常に容易であることも実感できると思います。</p><h3 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h3><p>以下の内容は以下の環境にて検証しました。</p><ul><li>OS：Windows 10 Enterprise バージョン 1903</li><li>IDE：Visual Studio 2019</li><li>Platform：.NET Core 3.1.401</li></ul><p>Visual Studio のインストールは<a href="https://docs.microsoft.com/ja-jp/visualstudio/install/install-visual-studio?view=vs-2019">こちら</a>を参考にしてください。</p><h3 id="今回作成する-Chat-サービスのインターフェース定義"><a href="#今回作成する-Chat-サービスのインターフェース定義" class="headerlink" title="今回作成する Chat サービスのインターフェース定義"></a>今回作成する Chat サービスのインターフェース定義</h3><p>今回の Chat サービスでは、<code>ChatRoom</code> が一つあり、そこにユーザが <code>Join</code> することで <code>Message</code> のやり取りができるものを考えます。</p><p>ユーザは一度 <code>ChatRoom</code> に <code>Join</code> すると、その <code>ChatRoom</code> 内での他のユーザの発言を知る必要があるため、Chat サーバ-Chatクライアント間には <code>Message</code> の流れる双方向ストリームが必要になります。</p><p>これを、 <code>chat.proto</code> として記述すると以下のようになります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package Chat;</span><br><span class="line"></span><br><span class="line">service ChatRoom &#123;</span><br><span class="line">  rpc join (stream Message) returns (stream Message) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Message &#123;</span><br><span class="line">  string user = 1;</span><br><span class="line">  string text = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gRPC-で通信する-Chat-サーバを-ASP-NET-Core-で実装する"><a href="#gRPC-で通信する-Chat-サーバを-ASP-NET-Core-で実装する" class="headerlink" title="gRPC で通信する Chat サーバを ASP.NET Core で実装する"></a>gRPC で通信する Chat サーバを ASP.NET Core で実装する</h3><p>まず Visual Studio を立ち上げ、「新しいプロジェクトの作成」から gRPC サービスのテンプレートを選択し、テンプレートプロジェクト（プロジェクト名： <code>GrpcChatServer</code> ）を作成します。</p><p>このとき、出来上がるテンプレートプロジェクトは、<a href="https://docs.microsoft.com/ja-jp/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-3.1&tabs=visual-studio">公式ドキュメント</a>のチュートリアルにおける、「 Greeter サービス」と同じものです。このテンプレートプロジェクトには、 <code>Grpc.AspNetCore (2.31.0)</code> という ASP.NET Core で gRPC アプリケーションを作成するために必要なパッケージがインストール済みです。</p><p>このテンプレートに手を加えて、 Chat サービスを実装していきます。</p><p>まず最初に、 <code>chat.proto</code> を <code>GrpcChatServer/Protos</code> にコピーします。続けて、 <code>GrpcChatServer.csproj</code> に下記　<code>&lt;ItemGroup&gt;</code> を追加します。ここで　<code>GrpcServices=&quot;Server&quot;</code> と記載することで、 <code>.proto</code> ファイルから gRPC サーバ用のコードが自動生成されることになります。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Protobuf</span> <span class="attr">Include</span>=<span class="string">&quot;Protos\*.proto&quot;</span> <span class="attr">GrpcServices</span>=<span class="string">&quot;Server&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>次に、 <code>ChatRoom</code> クラスを <code>ChatRoom.cs</code> に記述します。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">using Chat;</span><br><span class="line">using Grpc.Core;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Collections.Concurrent;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace GrpcChatServer</span><br><span class="line">&#123;</span><br><span class="line">    public class ChatRoom</span><br><span class="line">    &#123;</span><br><span class="line">        private ConcurrentDictionary&lt;string, IServerStreamWriter&lt;Message&gt;&gt; users = new ConcurrentDictionary&lt;string, IServerStreamWriter&lt;Message&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        public bool HasJoined(string name) =&gt; users.ContainsKey(name);</span><br><span class="line">        public void Join(string name, IServerStreamWriter&lt;Message&gt; response)</span><br><span class="line">        &#123;</span><br><span class="line">            users.TryAdd(name, response);</span><br><span class="line">            Console.WriteLine($&quot;[INFO] &#123;name&#125; has joined the rooom.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void Remove(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            users.TryRemove(name, out var _);</span><br><span class="line">            Console.WriteLine($&quot;[INFO] &#123;name&#125; has left the room.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task BroadcastMessageAsync(Message message)</span><br><span class="line">        &#123;</span><br><span class="line">            await BroadcastMessages(message);</span><br><span class="line">            Console.WriteLine($&quot;[INFO] &#123;message.User&#125; has broadcasted a message &#x27;&#123;message.Text&#125;&#x27;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private async Task BroadcastMessages(Message message)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var user in users.Where(x =&gt; x.Key != message.User))</span><br><span class="line">            &#123;</span><br><span class="line">                var item = await SendMessageToSubscriber(user, message);</span><br><span class="line">                if (item != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Remove(item?.Key);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private async Task&lt;Nullable&lt;KeyValuePair&lt;string, IServerStreamWriter&lt;Message&gt;&gt;&gt;&gt; SendMessageToSubscriber(KeyValuePair&lt;string, IServerStreamWriter&lt;Message&gt;&gt; user, Message message)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                await user.Value.WriteAsync(message);</span><br><span class="line">                // Console.WriteLine($&quot;[INFO] broadcast message &#x27;&#123;message.Text&#125;&#x27; from &#x27;&#123;message.User&#125;&#x27;.&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">                // Console.WriteLine(ex);</span><br><span class="line">                return user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上で定義した <code>ChatRoom</code> を利用する <code>ChatService</code> を <code>ChatService.cs</code> に記述します。このとき、 <code>ChatService</code> クラスは gRPC によって自動生成された <code>ChatRoomBase</code> クラス ( <code>.proto</code> ファイルの <code>Service</code> に指定した名前の後に <code>Base</code> を付与して自動生成されるクラス) を継承する形で実装します。こうすることで、 Chat サービスを実装する際の通信回りの実装を基底クラスに委譲して、アプリ実装者はアプリケーションのロジックに専念することができるようになります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line">using Grpc.Core;</span><br><span class="line"></span><br><span class="line">using Chat;</span><br><span class="line"></span><br><span class="line">namespace GrpcChatServer</span><br><span class="line">&#123;</span><br><span class="line">    public class ChatService : Chat.ChatRoom.ChatRoomBase</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly ChatRoom _chatroomService;</span><br><span class="line">        private readonly ILogger&lt;ChatService&gt; _logger;</span><br><span class="line"></span><br><span class="line">        public ChatService(ChatRoom chatRoomService, ILogger&lt;ChatService&gt; logger)</span><br><span class="line">        &#123;</span><br><span class="line">            _chatroomService = chatRoomService;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override async Task join(IAsyncStreamReader&lt;Message&gt; requestStream, IServerStreamWriter&lt;Message&gt; responseStream, ServerCallContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!await requestStream.MoveNext()) return;</span><br><span class="line"></span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                if (!_chatroomService.HasJoined(requestStream.Current.User))</span><br><span class="line">                &#123;</span><br><span class="line">                    _chatroomService.Join(requestStream.Current.User, responseStream);</span><br><span class="line">                &#125;</span><br><span class="line">                await _chatroomService.BroadcastMessageAsync(requestStream.Current);</span><br><span class="line">            &#125; while (await requestStream.MoveNext());</span><br><span class="line"></span><br><span class="line">            _chatroomService.Remove(context.Peer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上で定義した <code>ChatRoom</code> および <code>ChatService</code> を <code>Startup.cs</code> にて登録することで Chat サーバは完成です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using Microsoft.AspNetCore.Builder;</span><br><span class="line">using Microsoft.AspNetCore.Hosting;</span><br><span class="line">using Microsoft.AspNetCore.Http;</span><br><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">using Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line">namespace GrpcChatServer</span><br><span class="line">&#123;</span><br><span class="line">    public class Startup</span><br><span class="line">    &#123;</span><br><span class="line">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class="line">        // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940</span><br><span class="line">        public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddGrpc();</span><br><span class="line">            services.AddSingleton&lt;ChatRoom&gt;(); // ここで ChatRoom を登録</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class="line">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">        &#123;</span><br><span class="line">            if (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.UseRouting();</span><br><span class="line"></span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapGrpcService&lt;ChatService&gt;(); // ここで ChatService を登録</span><br><span class="line"></span><br><span class="line">                endpoints.MapGet(&quot;/&quot;, async context =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように、 ASP.NET Core を用いて gRPC サービスを実装する際には、データのシリアライズや通信回りの実装を自動生成されたコードに委譲し、アプリケーション固有のロジックの実装に専念することができるようになります。</p><h3 id="gRPC-で通信する-Chat-クライアントを-ASP-NET-Core-で実装する"><a href="#gRPC-で通信する-Chat-クライアントを-ASP-NET-Core-で実装する" class="headerlink" title="gRPC で通信する Chat クライアントを ASP.NET Core で実装する"></a>gRPC で通信する Chat クライアントを ASP.NET Core で実装する</h3><p>Visual Studio を立ち上げ、「新しいプロジェクトの作成」から「コンソールアプリ（.NET Core）」を選択し、テンプレートプロジェクト（プロジェクト名： <code>GrpcChatClient</code> ）を作成します。</p><p>まず最初に以下の三つのパッケージを <code>GrpcChatClient</code> にインストールします。</p><ul><li><code>Google.Protobuf (2.31.0)</code></li><li><code>Grpc.Net.Clien (2.31.0)</code></li><li><code>Grpc.Tools (2.31.0)</code></li></ul><p>つづけて、 <code>GrpcChatClient</code> プロジェクト内に <code>Protos</code> フォルダを作成し、<code>GrpcChatServer</code> と同じ <code>chat.proto</code> ファイルをコピーし、 <code>GrpcChatClient.csproj</code> に以下の <code>&lt;ItemGroup&gt;</code> を追加します。ここでも同様に<code>GrpcServices=&quot;Client&quot;</code> と記載することで、 <code>.proto</code> ファイルから gRPC クライアント用のコードが自動生成されることになります。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Protobuf</span> <span class="attr">Include</span>=<span class="string">&quot;Protos\*.proto&quot;</span> <span class="attr">GrpcServices</span>=<span class="string">&quot;Client&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最後に、 <code>Program.cs</code> に Chat クライアントのコードを記述してクライアントの実装は終了です。クライアントの実装では、サーバの実装と同様に gRPC によって自動生成されたクライアント用コードを <code>using</code> することで用います。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">using Grpc.Net.Client;</span><br><span class="line">using Chat; // ここで gRPC によって自動生成されたコードを利用することを宣言</span><br><span class="line"></span><br><span class="line">namespace GrpcChatClient</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static async Task Main()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;[INFO] Hello World! I am GrpcChatClient!&quot;);</span><br><span class="line">            Console.Write(&quot;Input your user name: &quot;);</span><br><span class="line"></span><br><span class="line">            var userName = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);</span><br><span class="line">            var client = new ChatRoom.ChatRoomClient(channel);</span><br><span class="line"></span><br><span class="line">            using (var chat = client.join())</span><br><span class="line">            &#123;</span><br><span class="line">                _ = Task.Run(async () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    while (await chat.ResponseStream.MoveNext(cancellationToken: CancellationToken.None))</span><br><span class="line">                    &#123;</span><br><span class="line">                        var response = chat.ResponseStream.Current;</span><br><span class="line">                        Console.WriteLine($&quot;[&#123;response.User&#125;]: &#123;response.Text&#125;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                await chat.RequestStream.WriteAsync(new Message &#123; User = userName, Text = $&quot;[INFO] &#123;userName&#125; has joined the room.&quot; &#125;);</span><br><span class="line"></span><br><span class="line">                string line;</span><br><span class="line">                while ((line = Console.ReadLine()) != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (line.ToLower() == &quot;bye&quot;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    await chat.RequestStream.WriteAsync(new Message &#123; User = userName, Text = line &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                await chat.RequestStream.CompleteAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;[INFO] Disconnecting...&quot;);</span><br><span class="line">            await channel.ShutdownAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここまで終了したら、いよいよサーバとクライアントを通信させることができます。</p><p>複数コマンドプロンプトを立ち上げて、サーバとクライアントをそれぞれ実行し、通信することができるかを確かめてみましょう。</p><p><img src="/jpwebapps/web-apps/GrpcChatOnAspNetCore/2client1server.png" alt="クライアント2つ、サーバ1つで通信させた様子"></p><p>（画像右半分がサーバアプリの画面、画像左半部がクライアントアプリの画面）</p><h3 id="gRPC-で通信する-Chat-クライアントを-go-で実装する"><a href="#gRPC-で通信する-Chat-クライアントを-go-で実装する" class="headerlink" title="gRPC で通信する Chat クライアントを go で実装する"></a>gRPC で通信する Chat クライアントを go で実装する</h3><p>gRPC は、サービスのインタフェースが Protocol Buffer という、プログラミング言語とは独立した形で記述されることから、互いに異なるプログラミング言語を用いてサーバとクライアントを開発することが容易であるという特徴があります。</p><p>そこで、ここまでで開発した Chat サーバと通信する Chat クライアントを C# とは別の <a href="https://golang.org/">Go</a> という言語で開発してみましょう。なお、今回はあくまで検証用のサンプルのご紹介であり、go 言語のサンプルアプリのサポートや以下の環境構築に関するサポートは弊社では行っておりませんことご了承ください。</p><p>Windows における Go/gRPC 開発環境の構築については下記サイトなどを参考に行ってください。</p><p>参考：<a href="https://golang.org/doc/install">https://golang.org/doc/install</a><br>参考：<a href="https://grpc.io/blog/installation/">https://grpc.io/blog/installation/</a></p><p>Go でのクライアント実装でも、コマンドで通信部分のソースコードを自動生成し、それを利用する形でクライアントを記述していくことには変わりありません。</p><p>Chat クライアントの Go 実装については下記リポジトリを参考にしてください。</p><p>Go クライアントリポジトリ：<a href="https://github.com/microsoft/jpwebapps/GrpcChatSample/tree/master/GrpcChatClientGo/chat">https://github.com/microsoft/jpwebapps/GrpcChatSample/tree/master/GrpcChatClientGo/chat</a></p><h3 id="実際に通信させてみる"><a href="#実際に通信させてみる" class="headerlink" title="実際に通信させてみる"></a>実際に通信させてみる</h3><p>Go 実装のクライアントと C# 実装のクライアント、 C# 実装のサーバを立ち上げ実際に通信できることを確認してみます。</p><p><img src="/jpwebapps/web-apps/GrpcChatOnAspNetCore/3client1server.png" alt="Go 実装クライアントと C# 実装クライアントが C# 実装サーバと通信をしている様子"></p><p>（画像右上がサーバアプリの画面、画像下半分が C# クライアントアプリの画面、画像左上が Go クライアントアプリの画面）</p><p>このように、 gRPC では異なる言語によるサーバ・クライアントの実装が容易に実現することができます。</p><p>今回作ったチャットアプリのコードは以下のリポジトリにあります。</p><p>リポジトリ：<a href="https://github.com/microsoft/jpwebapps/GrpcChatSample">https://github.com/microsoft/jpwebapps/GrpcChatSample</a></p><h2 id="他のサンプルも見てみたい方へ"><a href="#他のサンプルも見てみたい方へ" class="headerlink" title="他のサンプルも見てみたい方へ"></a>他のサンプルも見てみたい方へ</h2><p>今回は gRPC を使った Chat サービスを ASP.NET Core を利用して実装してみました。<br>gRPC では他にも様々な通信をサポートしており、 ASP.NET Core による実装例も以下のリポジトリから確認することができます。</p><p>ASP.NET Core を利用した gRPC 開発を検討の際には、開発したいものに合わせたサンプルを参照すると、参考になるかと思います。</p><p>サンプルリポジトリ：<a href="https://github.com/grpc/grpc-dotnet/tree/master/examples">https://github.com/grpc/grpc-dotnet/tree/master/examples</a></p><p>今回は以上です。<br>ASP.NET CoreでgRPCを簡単に実装できることがお分かりいただけましたでしょうか？<br>それでは、また次回！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。&lt;br&gt;Developer Support Internet チーム にてインターンをしている尾崎耀一と申します！&lt;/p&gt;
&lt;p&gt;今回は ASP.NET Core を用いて、 gRPC で動く CLI （コマンドライン）でチャットができるアプリを作る方法を紹介し</summary>
      
    
    
    
    
    <category term="ASP.NET Core" scheme="https://microsoft.github.io/jpwebapps/tags/ASP-NET-Core/"/>
    
    <category term="gRPC" scheme="https://microsoft.github.io/jpwebapps/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>WCF のバインディング処理にて競合状態により起きる問題</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/wcf-indexoutofrangeexception/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/wcf-indexoutofrangeexception/</id>
    <published>2020-05-26T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.398Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです。</p><p>今回は WCF のバインディング処理にて競合状態により起きる問題についてご説明いたします。<br>1 つのプロセス (IIS でホストしている場合は同一アプリケーションプール) で複数の WCF のバインディングをご利用で、以下の例外とスタックトレースが記録される場合がございます。<br>これは下記コミュニティより報告があり、調査が進められた結果、弊社製品の問題と判断され、修正が検討されています。(2020/5/27 時点)</p><p>IndexOutOfRangeException in MessageSecurityOverHttpElement when creating WCF client from service reference<br><a href="https://developercommunity.visualstudio.com/content/problem/692599/indexoutofrangeexception-in-messagesecurityoverhtt.html">https://developercommunity.visualstudio.com/content/problem/692599/indexoutofrangeexception-in-messagesecurityoverhtt.html</a></p><h2 id="例外-例外メッセージ"><a href="#例外-例外メッセージ" class="headerlink" title="例外/例外メッセージ"></a>例外/例外メッセージ</h2><p>System.IndexOutOfRangeException/インデックスが配列の境界外です。</p><h2 id="スタックトレース"><a href="#スタックトレース" class="headerlink" title="スタックトレース"></a>スタックトレース</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">場所 System.Collections.ArrayList.ArrayListEnumeratorSimple.MoveNext()</span><br><span class="line">場所 System.Configuration.PropertyInformationCollection..ctor(ConfigurationElement thisElement)</span><br><span class="line">場所 System.ServiceModel.Configuration.MessageSecurityOverHttpElement.ApplyConfiguration(MessageSecurityOverHttp security)</span><br><span class="line">場所 System.ServiceModel.Configuration.NonDualMessageSecurityOverHttpElement.ApplyConfiguration(NonDualMessageSecurityOverHttp security)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LookupBinding(String bindingSectionName, String configurationName, BindingCollectionElement bindingCollectionElement, Binding defaultBinding)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LookupBinding(String bindingSectionName, String configurationName, ContextInformation context)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LoadChannelBehaviors(ServiceEndpoint serviceEndpoint, String configurationName)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory.ApplyConfiguration(String configurationName, Configuration configuration)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory.InitializeEndpoint(String configurationName, EndpointAddress address)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory`1..ctor(String endpointConfigurationName, EndpointAddress remoteAddress)</span><br><span class="line">場所 System.ServiceModel.ConfigurationEndpointTrait`1.CreateSimplexFactory()</span><br><span class="line">場所 System.ServiceModel.ClientBase`1.CreateChannelFactoryRef(EndpointTrait`1 endpointTrait)</span><br><span class="line">場所 System.ServiceModel.ClientBase`1.InitializeChannelFactoryRef()</span><br></pre></td></tr></table></figure><p>回避策、対処方法としては以下の 2 点ございます。</p><ol><li>WCF のアプリケーションにおいてクライアントのクラスをインスタンス化を複数同時に発生しないよう排他制御を行っていただく</li><li>プロセスの再起動を行う (IIS でホストしている場合にはアプリケーションプールのリサイクル) </li></ol><p>ご不便をおかけしており誠に恐れ入りますが、何卒よろしくお願いいたします。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。IIS サポート チームです。&lt;/p&gt;
&lt;p&gt;今回は WCF のバインディング処理にて競合状態により起きる問題についてご説明いたします。&lt;br&gt;1 つのプロセス (IIS でホストしている場合は同一アプリケーションプール) で複数の WCF のバインディングをご</summary>
      
    
    
    
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="WCF" scheme="https://microsoft.github.io/jpwebapps/tags/WCF/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の Portal 上の事象の調査に必要な情報</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-bot-service/bot-portal-log-collection/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-bot-service/bot-portal-log-collection/</id>
    <published>2020-05-10T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.375Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure Bot Service サポート チームの大嶋です！  </p><p>以前 Azure Bot Service (Web App Bot もしくは Bot Channels Registration) のボットの動作に関する情報採取について以下をご紹介しましたが、今回は Azure Bot Service をご利用する際に、Azure Portal 上で問題が起こった際に必要となることが多い再現手順と通信ログの情報採取をご紹介いたします。</p><p>現象により必要な情報は異なりますが、今回はほとんどの Azure Bot Service の Portal 上の問題に関する調査に対して有効な情報について以下にご紹介いたします。</p><p>例えば、以下のような問題があげられます。</p><ul><li>Azure Portal 上にて Azure Bot Service のリソース作成時にエラーがでる</li><li>Azure Portal 上の Azure Bot Service リソースのあるパネルのページのみ正常に開けない</li></ul><br /><hr><h2 id="0-前置き"><a href="#0-前置き" class="headerlink" title="0. 前置き"></a>0. 前置き</h2><p>Azure Bot Service 作成時に出力されるエラーとして例えば以下のようなものがあり、<br>それぞれ該当する回避策を実施することで回避できる可能性がございます。<br>もし該当のエラーが出ているような場合にはまずは以下をお試しください。</p><h4 id="パターン-1-Azure-Bot-Service-作成時に-“Authorization-RequestDenied”-エラー"><a href="#パターン-1-Azure-Bot-Service-作成時に-“Authorization-RequestDenied”-エラー" class="headerlink" title="パターン 1 : Azure Bot Service 作成時に “Authorization_RequestDenied” エラー"></a>パターン 1 : Azure Bot Service 作成時に “Authorization_RequestDenied” エラー</h4><p>Azure Bot Service 作成時に “Authorization_RequestDenied” エラー が出ている<br>場合は、以下の事象に該当している可能性が高いので、下記情報をまずはご参照ください。</p><p>参考：Bot 作成時に “Authorization_RequestDenied” エラーが出力される<br><a href="https://social.msdn.microsoft.com/Forums/en-US/eecc490d-4d0a-4e8d-bc90-3f927ebe78c6/bot-authorizationrequestdenied-?forum=azurebotsupportteamja">https://social.msdn.microsoft.com/Forums/en-US/eecc490d-4d0a-4e8d-bc90-3f927ebe78c6/bot-authorizationrequestdenied-?forum=azurebotsupportteamja</a></p><p>参考 : ボットを作成するときに Authorization_RequestDenied という例外が発生するのはなぜですか。<br><a href="https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#why-do-i-get-an-authorization_requestdenied-exception-when-creating-a-bot">https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#why-do-i-get-an-authorization_requestdenied-exception-when-creating-a-bot</a></p><h4 id="パターン-2-Azure-Bot-Service-作成時に-“Can’t-register-resource-provider-‘Microsoft-BotService’”-エラー"><a href="#パターン-2-Azure-Bot-Service-作成時に-“Can’t-register-resource-provider-‘Microsoft-BotService’”-エラー" class="headerlink" title="パターン 2 : Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService’” エラー"></a>パターン 2 : Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService’” エラー</h4><p>Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService” エラー が出ている場合は、<br>下記サイトを参考に Microsoft.BotService のリソースプロバイダーのご確認と登録を実施ください。</p><p>参考：リソース プロバイダーの登録エラーの解決<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/error-register-resource-provider#solution-3---azure-portal">https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/error-register-resource-provider#solution-3---azure-portal</a></p><hr><h2 id="1-事象解消のために考えうる回避案"><a href="#1-事象解消のために考えうる回避案" class="headerlink" title="1. 事象解消のために考えうる回避案"></a>1. 事象解消のために考えうる回避案</h2><p>上記 0 に該当しない場合、もしくはそれぞれの回避策を実施しても解決しない場合、<br>本事象が一時的な問題の可能性もございますので、以下をそれぞれ実施頂き、<br>いずれかで事象が解消するかどうか、まずは以下の手順でご確認ください。</p><h3 id="確認事項-1-ブラウザのシークレットモードで確認"><a href="#確認事項-1-ブラウザのシークレットモードで確認" class="headerlink" title="確認事項 1 :ブラウザのシークレットモードで確認"></a>確認事項 1 :ブラウザのシークレットモードで確認</h3><p>一旦開いているブラウザ等を閉じ、ブラウザ (Google Chrome や Microsoft Edge など) のシークレットウィンドウにて<br>Azure Portal を新たに開き、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。</p><h3 id="確認事項-2-ポータルの言語設定を英語に変更し、確認"><a href="#確認事項-2-ポータルの言語設定を英語に変更し、確認" class="headerlink" title="確認事項 2 : ポータルの言語設定を英語に変更し、確認"></a>確認事項 2 : ポータルの言語設定を英語に変更し、確認</h3><p>上記のシークレットモードのまま、Azure Portal を開き、右上の設定アイコンの以下の操作で言語を<br>[English] に変更し、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。 </p><h3 id="確認事項-3-時間をおいて確認"><a href="#確認事項-3-時間をおいて確認" class="headerlink" title="確認事項 3 : 時間をおいて確認"></a>確認事項 3 : 時間をおいて確認</h3><p>時間を一定時間空けてから、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。 </p><p>もし上記の 3 つでも正常でない場合、以下の情報を採取しそれを基に調査方針を検討することが可能です。<br>主に、以下の手順ではクライアント側の HTTP 通信の応答と、具体的な再現時の操作状況を確認いたします。</p><hr><h2 id="情報採取-Fiddler-ログ、問題ステップ記録ツール-PSR-のログ"><a href="#情報採取-Fiddler-ログ、問題ステップ記録ツール-PSR-のログ" class="headerlink" title="情報採取 : Fiddler ログ、問題ステップ記録ツール (PSR) のログ"></a>情報採取 : Fiddler ログ、問題ステップ記録ツール (PSR) のログ</h2><p>弊社サポート対象外のツールではございますが、 Fiddler というツールを利用することで HTTPS の通信を含めたキャプチャを取得することが可能です。<br>本ツールをご利用いただくには、対象の端末に本ツールをインストールしていただく必要があります。<br>以下に、HTTPS 通信を含めたネットワークアクセスのキャプチャ手順をご案内いたします。</p><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><h4 id="1-Fiddler-のダウンロード"><a href="#1-Fiddler-のダウンロード" class="headerlink" title="1. Fiddler のダウンロード"></a>1. Fiddler のダウンロード</h4><p>以下のサイトから、Fiddler4 をダウンロードし、トレースを取得する端末にインストールします。</p><p>Download Fiddler<br><a href="https://www.telerik.com/download/fiddler/fiddler4">https://www.telerik.com/download/fiddler/fiddler4</a></p><h4 id="2-Portal-上の言語の変更"><a href="#2-Portal-上の言語の変更" class="headerlink" title="2. Portal 上の言語の変更"></a>2. Portal 上の言語の変更</h4><p>ポータルの言語設定を上記の確認事項 2 のように、言語設定を [英語 (English)]に変更します。<br>確認事項 1 のように、Chrome などのブラウザの [シークレットモード] で Azure Portal (<a href="https://portal.azure.com/">https://portal.azure.com/</a>) を再度新たに開きます。<br>※ まだ再現手順は行わずに、Azure Portal 上のトップページのまま、以下の手順 3 を実施します。</p><h3 id="情報採取"><a href="#情報採取" class="headerlink" title="情報採取"></a>情報採取</h3><h4 id="3-PSR-採取開始"><a href="#3-PSR-採取開始" class="headerlink" title="3. PSR 採取開始"></a>3. PSR 採取開始</h4><p>Windows 標準の画面キャプチャソフトである問題ステップ記録ツール (PSR) を起動します。</p><p>3-1.クライアントにて、Win + R キーを押し、[ファイル名を指定して実行] より “psr” と入力し、[OK] をクリックします。</p><p>3-2. [ステップ記録ツール] が起動しましたら、右端の ▼ をクリックし、[設定] をクリックします。</p><p>3-3. [保存する最新の取り込み画像数] を “25” から “150” に変更し [OK] をクリックします。</p><p>3-4. [記録の開始] をクリックします。</p><h4 id="4-Fiddler-ログの採取と-PSR-の採取終了"><a href="#4-Fiddler-ログの採取と-PSR-の採取終了" class="headerlink" title="4. Fiddler ログの採取と PSR の採取終了"></a>4. Fiddler ログの採取と PSR の採取終了</h4><p>4-1. 接続元クライアントにて、Fiddler を起動します。</p><p>4-2. Fiddler のメニュー バーから [Tools] - [Fiddler Options] を選択します。</p><p>4-3. HTTPS タブをクリックし、”Capture HTTPS CONNECTS” および “Decrypt HTTPS traffic” のチェック ボックスをオンにし、OK ボタンをクリックし、Fiddler Options を閉じます。</p><ul><li>“Decrypt HTTPS traffic” のチェック ボックスをオンにすることで、以下の警告が表示されますので、Yes ボタンをクリックします。<br>“Fiddler generates a unique root CA certificate to intercept HTTPS traffic. You may choose to have Windows trust this root certificate to avoid security warnings about the untrusted root certificate. You should ONLY click ‘Yes’ on a computer used exclusively for TEST purposes.”</li><li>上記警告で Yes を選択すると、セキュリティ警告が表示されますので、”はい” を選択します。<br>これにより、個人ストア、および信頼されたルート証明機関ストアに発行者が “DO_NOT_TRUST_FiddlerRoot” である証明書が追加されます。</li></ul><p>4-4. 画面右側にある Filters - User Filter がオフになっていることを確認します。</p><p>4-5. Fiddler のキャプチャ画面にアクセスがトレースされていることを確認してください。</p><p>4-6. Azure Portal 上で現象を再現させます。</p><p>4-7. 現象やエラー等を確認できましたら、Fiddler のメニュー バーから [File] - [Save] - [All Sessions] を選択し、.saz 形式でログを保存します。</p><p>4-8. PSR の画面で [記録の停止] をクリックします。</p><p>4-9. PSR の画面で [保存] をクリックし、ファイルの保存場所、ファイル名を指定し、[保存] をクリックします。</p><p>4-10. Fiddler を終了します。</p><p>4-11. PSR と Fiddler で採取した情報を基に調査を行います。</p><h4 id="5-Fiddler-アンインストールについて-任意"><a href="#5-Fiddler-アンインストールについて-任意" class="headerlink" title="5. Fiddler アンインストールについて (任意)"></a>5. Fiddler アンインストールについて (任意)</h4><p>アンインストールについては下記をご参考にいただければと存じます。</p><p>5-1. コントロール パネルから [プログラムと機能] を選択します。</p><p>5-2. Fiddler をダブル クリックし、”Uninstall” ボタンをクリックしアン インストールします。</p><p>5-3. [スタート] - [検索の開始] に certmgr.msc と入力し、Enter キーを押下します。</p><p>5-4. 証明書管理スナップインの左ペインから、[個人] - [証明書] を展開し、右ペインから発行者が “DO_NOT_TRUST_FiddlerRoot” となっている全ての証明書に関して、証明書を右クリックし、”削除” を選択し、証明書を削除します。</p><p>5-5. 証明書管理スナップインの左ペインから、[信頼されたルート証明機関] - [証明書] を展開し、右ペインから発行者が “DO_NOT_TRUST_FiddlerRoot” となっている全ての証明書に関して、証明書を右クリックし、”削除” を選択し、証明書を削除します。</p><p>※ なお、Fiddler 自体のツールに関するトラブルシューティングや操作方法等のご質問は 3 rd party 製品となる為、本 Azure サポートでは承ることができませんのでご了承ください。</p><br /><p>上記を基に私共サポートにて Azure Bot Service リソースにおける Azure Portal 上の事象に関して調査を承ることが可能です。</p><p>なお、状況に応じて、例えば Azure Bot Service のそのほかの情報や詳細な画面キャプチャなど追加の情報が必要になることも多々ございますが、上記をまず確認した上で、より詳細な調査に向けて調査方針や追加の情報採取を検討していくことが可能となります。</p><p>今回は以上です。それでは、また次回！</p><br />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure Bot Service サポート チームの大嶋です！  &lt;/p&gt;
&lt;p&gt;以前 Azure Bot Service (Web App Bot もしくは Bot Channels Registration) のボットの動作に関する情報採取について以下をご</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
    <category term="Azure Portal" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Portal/"/>
    
  </entry>
  
  <entry>
    <title>Web App Bot の常時接続について</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-bot-service/bot-alwayson/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-bot-service/bot-alwayson/</id>
    <published>2020-04-22T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.352Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。</p><p>こんにちは。Azure Bot Service Support Team の大嶋です。</p><p>Web App Bot をご利用の際に、ボットに ”暫く経ってからアクセスした際にレスポンスが遅いように感じる” といったような事がある場合があります。今回は、そんな時に事象解消の手助けができるような方法についてご紹介します。</p><p>まずはなぜ “暫く経ってからアクセスした際にレスポンスが遅いように感じる” といったことが起こるのかについて、下記にて記載させていただきます。</p><br /><hr><h2 id="考えられる原因について"><a href="#考えられる原因について" class="headerlink" title="考えられる原因について"></a>考えられる原因について</h2><p>まず、Web App Bot については、Bot アプリケーションを Azure App Service 上にホストするものです。</p><p>なお、Web App Bot などの Azure Bot Service の種類に関しては下記の前回の Blog 記事をご参照ください。</p><p>参考 : Azure Bot Service サポートチーム - Azure Bot Service の種類について<br><a href="https://social.msdn.microsoft.com/Forums/ja-JP/74ec7be1-10f9-4faf-af31-89c0d36cec6f/azure-bot-service-?forum=azurebotsupportteamja">https://social.msdn.microsoft.com/Forums/ja-JP/74ec7be1-10f9-4faf-af31-89c0d36cec6f/azure-bot-service-?forum=azurebotsupportteamja</a></p><p>ホストする Azure App Service では一定期間アイドル状態になるとリソース節約のために、Web アプリは自動的にアンロードされるような機能が備わっております。</p><p>この機能により、システムリソースを節約できる一方で、Web アプリがアンロードされた後の最初の要求への応答が結果的に長くなります。</p><p>Web App Bot をご利用の際に ”暫く経ってからアクセスした際にレスポンスが</p><p>遅いように感じる” といった事象の原因の多くが上記の機能の影響と考えられます。</p><hr><h2 id="考えられる解決法について"><a href="#考えられる解決法について" class="headerlink" title="考えられる解決法について"></a>考えられる解決法について</h2><p>上記の機能を無効にするためには Bot をホストする Azure App Service で [常時接続] をオンにします。</p><p>具体的には、下記が [常時接続] の設定を変更する手順となります。</p><ol><li>Azure Portal で、ホストする Azure App Service のリソースに移動します。</li><li>[構成] を選択し、上部の [全般設定] タブを選択します。</li><li>[常時接続] の [On] (オン) を選択し、保存します。</li></ol><p>参考 : Azure での Web アプリのアプリケーションパフォーマンスに関するよくあるご質問 – 常時接続<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/faq-availability-performance-application-issues#how-do-i-decrease-the-response-time-for-the-first-request-after-idle-time">https://docs.microsoft.com/ja-jp/azure/app-service/faq-availability-performance-application-issues#how-do-i-decrease-the-response-time-for-the-first-request-after-idle-time</a></p><p>参考 : Azure Bot Service - 一般的な問題のトラブルシューティング – 常時接続<br><a href="https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#my-bot-is-slow-to-respond-to-the-first-message-it-receives-how-can-i-make-it-faster">https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#my-bot-is-slow-to-respond-to-the-first-message-it-receives-how-can-i-make-it-faster</a></p><p>なお、利用する App Service Plan によって制限があり、その注意点についても下記にて記載いたします。</p><h3 id="上記設定の変更に必要な-App-Service-Plan"><a href="#上記設定の変更に必要な-App-Service-Plan" class="headerlink" title="上記設定の変更に必要な App Service Plan"></a>上記設定の変更に必要な App Service Plan</h3><p>2019 年 9 月現在、上記の設定を変更するには、Basic 以上の App Service Plan が必要となります。</p><p>参考 : App Service プラン<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/app-service/plans/">https://azure.microsoft.com/ja-jp/pricing/details/app-service/plans/</a></p><p>Free や Shared の App Service Plan をご利用の場合には、Basic 以上のプランへのスケールアップをご検討ください。</p><p>参考 : Azure でのアプリのスケールアップ<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale">https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale</a></p><p>なお、Free プラン等のプランをご利用の場合は設定部分が既定のオフのままグレーアウトされます。</p><p><img src="/jpwebapps/azure-bot-service/bot-alwayson/lowplan.png" alt="lowplan"></p><hr><h2 id="QnA-Maker-を連携してご利用の場合"><a href="#QnA-Maker-を連携してご利用の場合" class="headerlink" title="QnA Maker を連携してご利用の場合"></a>QnA Maker を連携してご利用の場合</h2><p>Web App Bot と QnA Maker を連携してご利用の方々も多いかと存じます。</p><p>その場合には、QnA Maker のリソースで利用している側の Azure App Service についても、上記の Web App Bot の Azure App Service と同様に、[常時接続] を ON に設定変更頂く必要がございます。</p><p>今回の内容としては以上となります。</p><p>また、全体的なレスポンスの一般的なパフォーマンス向上という観点では、App Service Plan のスケールアップも有効かと存じますので、こちらも状況に応じてご検討ください。 </p><p>参考 : Azure でのアプリのスケールアップ<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale">https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale</a></p><p>それでは、また。</p><br />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。&lt;/p&gt;
&lt;p&gt;こんにちは。Azure Bot Service Support Team の大嶋です。&lt;/p&gt;
&lt;p&gt;Web App Bot をご利用の際</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
    <category term="Azure App Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-App-Service/"/>
    
    <category term="設定" scheme="https://microsoft.github.io/jpwebapps/tags/%E8%A8%AD%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の料金やプランについて</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-bot-service/bot-plan/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-bot-service/bot-plan/</id>
    <published>2020-04-22T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.373Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。</p><p>こんにちは。Azure Bot Service Support Team です。</p><p>今回は Azure Bot Service の料金やプランについて、以下の Azure Bot Service の価格のページを元に説明します。</p><p>Azure Bot Service の価格<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/bot-service/">https://azure.microsoft.com/ja-jp/pricing/details/bot-service/</a></p><p>Azure Bot Service には Free(F0) と Standard(S1) の 2 つのプランがあります。</p><p><img src="/jpwebapps/azure-bot-service/bot-plan/botplan.png" alt="plan"></p><p>Azure ポータルから Web App Bot 等の Azure Bot Service のリソースを作成しようとした際に表示される価格レベルがこちらに当たります。</p><p><img src="/jpwebapps/azure-bot-service/bot-plan/portalplan.png" alt="portalplan"></p><p>上記の通り、プランを利用することに対してかかる料金はありませんが、ユーザーと Bot がチャネルを介してやりとり (会話) するメッセージに対して、選択するプランおよびチャネルごとに料金や制限がかかります。</p><p>ここで「チャネル」という単語が出てきましたが、Azure Bot Service では開発した Bot アプリケーションを複数のチャネルを経由して利用できます。例えば、開発した Bot に対して Microsoft Teams チャネルを有効にすることで Microsoft Teams クライアントから 1 on 1 のチャットやチームのチャネルから会話でき、かつ、同じ Bot に対して LINE チャネルも有効にすることで LINE アプリからも会話するといったことができます。</p><p>チャネルには Standard チャネルと Premium チャネルの 2 種類があり、それぞれのチャネルとしては以下が用意されています (2019 年 7 月現在)。「Azure Bot Service の価格」ページの画面下部の FAQ にも少し説明がありますので、ご覧ください。</p><p><img src="/jpwebapps/azure-bot-service/bot-plan/channels.png" alt="channels"></p><p>1 つの Bot アプリケーションに対して、複数のチャネルを有効にすることができ、また、複数のチャネルを利用しても追加の料金はありません。また、Standard チャネルを利用する場合は、プランが Free であっても Standard であっても料金はかからず、かつ、制限も変わりません。</p><p>つまり、上述の Standard チャネルのいずれかのみを介して Bot を利用する予定の場合は、Free プランを選択していただければ、Azure Bot Service に対する料金はかかりません。</p><p>一方、Premium チャネルを利用する予定がある場合は、Free プランでは月ごとにメッセージ数が 10,000 という上限があるため、その上限を超えるかどうかを元に、Free プランを選択するか、Standard プランを選択するかを検討していただく必要があります。ここで注意いただく必要がある点は以下になります。</p><ol><li>メッセージ数のカウントは、ユーザーが bot に送ったメッセージの数と、bot からユーザーに送られたメッセージ数の合算になります。つまり、以下のようなやりとりが実施された場合、メッセージ数は 3 になります。</li></ol><p><img src="/jpwebapps/azure-bot-service/bot-plan/chat1.png" alt="chat1"></p><ol start="2"><li>Free プランを選択し、Premium チャネルを利用したメッセージのやりとりが月ごとの上限を超えた場合、Bot に対してメッセージが送信できないようになります (何らかの理由で Bot にメッセージが届かない場合と同様の状況となり、Bot アプリケーションにてメッセージは処理されません)。</li></ol><p><img src="/jpwebapps/azure-bot-service/bot-plan/chat2.png" alt="chat2"></p><p>例)</p><p><img src="/jpwebapps/azure-bot-service/bot-plan/console429.png" alt="console429"></p><p>この際、Web Chat 等でアクセスした際にブラウザーの開発者ツール (Microsoft Edge の場合は F12 キーより起動) を利用してメッセージを送付すると、以下のようなエラーが返されていることがご確認いただけます。</p><p>上記のようなメッセージが返されている場合は、Standard プランへの変更をご検討ください。</p><p>また、Premium チャネルに対しては SLA (Service Level Agreement) が適用され、もし仮に障害が発生し、下記に記載の SLA を下回るようなことがあった場合に返金の対象となりますが、こちらは Standard プランをご利用いただいた場合にのみ適用となります。</p><p>Azure Bot Service の SLA<br><a href="https://azure.microsoft.com/ja-jp/support/legal/sla/bot-services/v1_0/">https://azure.microsoft.com/ja-jp/support/legal/sla/bot-services/v1_0/</a></p><p>上記のメッセージ数の上限や SLA を元にどちらのプランを選択されるか、ご検討ください。</p><p>なお、Azure Bot Service を利用することに対してかかる料金は以上となりますが、作成した Bot アプリケーションを配置する場所として Azure サービス (Azure Web App もしくは Azure Functions) を利用する場合や、Bot の使用量の分析やトラブルシュートに Application Insights サービスを利用する場合、また、Bot を LUIS や QnA といった自然言語処理サービスと連携する場合には、それぞれの料金が追加でかかります。</p><p>「Azure Bot Service の価格」ページの画面中部の「上記の料金とは別に、以下のリソース使用にも料金が発生します。」にも記載がありますが、こちらは次回 Azure Bot Service の種類の投稿にも記載予定ですので、ご参考いただければと思います。</p><p>それではまた。</p><br />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。&lt;/p&gt;
&lt;p&gt;こんにちは。Azure Bot Service Support Team です。&lt;/p&gt;
&lt;p&gt;今回は Azure Bot Service</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
    <category term="料金プラン" scheme="https://microsoft.github.io/jpwebapps/tags/%E6%96%99%E9%87%91%E3%83%97%E3%83%A9%E3%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の調査に必要な基本的な情報について</title>
    <link href="https://microsoft.github.io/jpwebapps/azure-bot-service/bot-log-collection/"/>
    <id>https://microsoft.github.io/jpwebapps/azure-bot-service/bot-log-collection/</id>
    <published>2020-04-21T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.355Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure Bot Service サポート チームの大嶋です！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てるのではないかということで、今回の記事の執筆に至っています。</p><p>Azure Bot Service (Web App Bot もしくは Bot Channels Registration) をご利用の場合、問題の原因はクライアントアプリケーション起因やホストする Bot アプリケーション起因、それらをホストする基盤起因、弊社管理のコネクタサーバー等多岐に渡るため、複数の情報を正確に把握し調査を進めていく必要があります。</p><p>お問い合わせいただいた後、これらの把握のために複数の情報をご提供いただくようお願いしておりますが、今回の記事で、その採取方法についてご紹介いたします！<br>現象により必要な情報は異なりますが、今回はほとんどの現象の調査に対して有効な情報について以下にご紹介いたします。</p><hr><h2 id="1-Azure-Portal-上の-Azure-Bot-Service-リソース情報について"><a href="#1-Azure-Portal-上の-Azure-Bot-Service-リソース情報について" class="headerlink" title="1. Azure Portal 上の Azure Bot Service リソース情報について"></a>1. Azure Portal 上の Azure Bot Service リソース情報について</h2><p>Azure 側での詳細な確認を行うために以下の 4 つをご提供ください。</p><p>1-1. Azure Bot Service の種類 (Web App Bot (Web アプリ ボット) か Bot Channels Registration (ボット チャンネル登録) のいずれか)<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の左上のリソース名の下に記載</p><p>1-2. Azure Bot Service の “リソース名”<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の左上にリソース名が記載</p><p>1-3. Azure Bot Service の  “メッセージング エンドポイント”<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の [概要] パネルの欄にメッセージング エンドポイントが記載</p><p><img src="/jpwebapps/azure-bot-service/bot-log-collection/endpoint.png" alt="build"></p><p>1-4. (Web App Bot ご利用の場合のみ) Web App Bot  に結び付く Azure App Service のリソース名<br>確認方法 : Web App Bot の左パネルの [すべての App Service 設定] &gt; App Service の画面に遷移後の左上にリソース名が記載</p><br /><h2 id="2-Azure-Bot-Service-の設定パネルの画面"><a href="#2-Azure-Bot-Service-の設定パネルの画面" class="headerlink" title="2. Azure Bot Service の設定パネルの画面"></a>2. Azure Bot Service の設定パネルの画面</h2><p>Azure Portal 上を Azure Bot Service の [設定] パネルの画面のスクリーンショットをご提供ください。</p><br /><h2 id="3-Web-App-Bot-ご利用の場合-Bot-アプリケーションをホストする-Azure-App-Service-の構成情報"><a href="#3-Web-App-Bot-ご利用の場合-Bot-アプリケーションをホストする-Azure-App-Service-の構成情報" class="headerlink" title="3. (Web App Bot ご利用の場合)  Bot アプリケーションをホストする Azure App Service の構成情報"></a>3. (Web App Bot ご利用の場合)  Bot アプリケーションをホストする Azure App Service の構成情報</h2><p>該当の Web App Bot (Azure Bot Service) の左パネルの [すべての App Service 設定] &gt; App Service の画面に遷移 &gt; [構成] &gt; 上部タブの [アプリケーション設定] で [値を表示する] をクリックし値を表示した上で撮影</p><p>(なお、左上部の Azure App Service のリソース名が表示されるように画面全体を撮影ください)</p><p><img src="/jpwebapps/azure-bot-service/bot-log-collection/config.png" alt="build"></p><br /><h2 id="4-エラーが発生するチャンネルの情報と再現時の情報"><a href="#4-エラーが発生するチャンネルの情報と再現時の情報" class="headerlink" title="4. エラーが発生するチャンネルの情報と再現時の情報"></a>4. エラーが発生するチャンネルの情報と再現時の情報</h2><p>調査を行う上で、どのチャンネルで発生しているか、再現時のクライアントはどういう状態になっているのかというのは重要と考えられますので、以下の情報についてご提供ください。</p><p>4-1. エラーが発生している利用チャンネル<br>例 : Web Chat チャンネルと LINE チャンネルを利用していてどちらでもエラーが発生する</p><p>4-2. エラー再現時のクライアントのチャット画面側の会話時のスクリーンショット</p><p>4-3. 上記のエラーが発生した正確な時刻(“時分秒” で可能な限り正確な時間をご提供ください)</p><p>4-4. 上記再現後のチャンネルの正常性のスクリーンショット<br>確認方法 : Azure Portal 上の該当の Azure Bot Service リソース画面の左パネル [チャンネル] の 4-1 の発生チャンネル の正常性が “問題 (数字)” になっている場合、その問題をクリック後に出る部分を含む画面全体のスクリーンショットを撮影</p><br /><h2 id="5-Web-チャットでテストで試行時の情報について"><a href="#5-Web-チャットでテストで試行時の情報について" class="headerlink" title="5.    Web チャットでテストで試行時の情報について"></a>5.    Web チャットでテストで試行時の情報について</h2><p>Azure Bot Service では様々なチャンネルが存在しますが、一番シンプルに試せるのが Azure Portal 上の[Web チャットでテスト] という機能です。チャネル固有の機能を利用していたり、認証等を利用している場合には別のエラーが出る可能性があるため、一概にはいえませんが、一番シンプルな問題の切り分けをこちらを利用して行うことが可能です。Web チャットでテストでお試し頂き、以下について情報をご提供ください。</p><p>5-1. Azure Bot Service のリソース画面の左パネルの [Web チャット でテスト] で話しかけたときの画面全体のスクリーンショット (なお、左上部のリソース名も含まれるように画面全体を撮影ください)</p><p>5-2. 上記の Web チャットでテストで会話した時刻 (“時分秒” で可能な限り正確な時間をご提供ください)</p><p>5-3. Azure Bot Service のリソース画面の左パネルの [チャンネル] の [Web Chat] の正常性が “問題 (数字)” になっている場合、その問題をクリック後に出る部分を含む画面全体のスクリーンショット</p><p>5-4. 再現手順 (どういったことをするとエラーが出るのかの再現ステップ)</p><br /><h2 id="6-ホストしている-Bot-アプリケーションのソースコード"><a href="#6-ホストしている-Bot-アプリケーションのソースコード" class="headerlink" title="6. ホストしている Bot アプリケーションのソースコード"></a>6. ホストしている Bot アプリケーションのソースコード</h2><p>エラーの調査については、一般的に再現性があり、意図的に再現できる手順が確立できていることが重要になります。<br>弊社側での再現確認のため、再現可能なホストしている Bot アプリケーションのソースコードを以下の手順でご提供ください。</p><p>なお Web App Bot (Web アプリボット) の場合は Azure Portal 上を Web App Bot の<br>[ビルド] パネルの [ボットのソース コードをダウンロードする] より、zip ファイルをダウンロードすることが可能です。</p><p><img src="/jpwebapps/azure-bot-service/bot-log-collection/build.png" alt="build"></p><br /><p>上記を基に私共サポートにて調査を承ることが可能です。なお、状況に応じて、例えば Application Insights の情報など追加の情報が必要になることも多々ございますが上記をまず確認した上で、より詳細な調査に向けて調査方針や追加の情報採取を検討していくことが可能となります。</p><p>今回は以上です。それでは、また次回！</p><br />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure Bot Service サポート チームの大嶋です！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てるのではないかということで、今回の記事の執筆に至っています。&lt;/p&gt;
&lt;p&gt;Azure Bot Se</summary>
      
    
    
    
    
    <category term="Azure Bot Service" scheme="https://microsoft.github.io/jpwebapps/tags/Azure-Bot-Service/"/>
    
    <category term="ログ採取" scheme="https://microsoft.github.io/jpwebapps/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>構成エディターの使用方法について</title>
    <link href="https://microsoft.github.io/jpwebapps/web-apps/ConfigurationEditor/"/>
    <id>https://microsoft.github.io/jpwebapps/web-apps/ConfigurationEditor/</id>
    <published>2020-04-09T15:00:00.000Z</published>
    <updated>2025-08-19T02:33:38.378Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。<br> <br>IIS サポート チームです！</p><p>[構成エディター] を使用することで、IIS マネージャー上の設定を変更する<br>コマンドレット（PowerShell）やコマンドを生成することが出来ます。</p><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic1.png" alt="reference"></p><p>この [構成エディター] は、弊社の公開情報でも設定手順が紹介されておりますが、<br>実情として、日本語で丁寧に書かれた情報はございません。</p><p>　Editing Collections with Configuration Editor<br>　<a href="https://docs.microsoft.com/en-us/iis/manage/managing-your-configuration-settings/editing-collections-with-configuration-editor">https://docs.microsoft.com/en-us/iis/manage/managing-your-configuration-settings/editing-collections-with-configuration-editor</a></p><p>　Configuration Editor<br>　<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/hh831362(v=ws.11)">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/hh831362(v=ws.11)</a></p><p>そこで、可能な限り、丁寧に [構成エディター] を使用してコマンドレットや<br>コマンドを生成する方法を以下にてご案内いたします。<br>なお、[構成エディター] 上にある全ての UI の説明は割愛させていただき、<br>以下では最小限の手順となります。</p><h2 id="1-前提と周辺情報"><a href="#1-前提と周辺情報" class="headerlink" title=" 1. 前提と周辺情報 "></a><u> 1. 前提と周辺情報 </U></h2><p>まず、IIS マネージャー上で、以下の設定を変更するコマンドレットや<br>コマンドを生成したいという要望があると仮定します。</p><p>“Default Web Site”<br>　- [ログ記録]<br>　　　- 右ペインの [有効にする], または [無効にする]</p><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic2.png" alt="reference"><br><img src="/jpwebapps/web-apps/ConfigurationEditor/pic3.png" alt="reference"></p><p>その場合、まず上記の設定を [構成エディター] 上で探すことが必要となります。<br>[構成エディター] 上では、IIS マネージャー上の設定は “セクション” と<br>呼ばれる箇所においてツリー状で存在しています。</p><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic4.png" alt="reference"></p><p>※ “セクション” は以下にある applicationHots.config ファイル内の要素に該当しています</p><p>　　%SystemRoot%\system32\inetsrv\config</p><p>　　故に、設定を変更したい項目を変更して、applicationHost.config 内のどの要素が<br>　　変更されたのかを確認（比較）することでも、当該設定が “セクション” 内の<br>　　いずれにあるかを探すことが出来ます</p><p>“セクション” 内のどの箇所に当該設定があるかを把握するためには、<br>以下のサイトにアクセスして検索することが可能です。</p><p>　Configuration Reference <configuration><br>　<a href="https://docs.microsoft.com/en-us/iis/configuration/">https://docs.microsoft.com/en-us/iis/configuration/</a></p><p>上記サイト左側にある configuration, administrators 等という項目が、<br>“セクション” に該当しています。</p><p>さて、この中から該当の設定を探すことになりますが、その場合に最も簡単な<br>方法といたしましては、[Filter by title] に関連するキーワードを入力する方法です。</p><p>それでは以下に、上記サイトにアクセスした後、コマンドレット、またはコマンドを<br>作成するまでの手順を記載いたします。</p><h2 id="2-手順"><a href="#2-手順" class="headerlink" title=" 2. 手順 "></a><u> 2. 手順 </U></h2><ol><li>英語での検索になりますが、[ログ記録] に関連するキーワードとして “log” で検索します</li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic5.png" alt="reference"></p><p>　　複数の候補が選択されている場合には、それぞれをクリックしていただくことで、<br>　　設定に関する公開情報にアクセスすることが出来ます<br>　　今回の設定に該当する公開情報は以下の URL となります</p><p>　　 Log Files for a Web Site <logFile><br>　　 <a href="https://docs.microsoft.com/en-us/iis/configuration/system.applicationhost/sites/site/logfile/">https://docs.microsoft.com/en-us/iis/configuration/system.applicationhost/sites/site/logfile/</a><br>　<br>　　 ※URL 内に、[ログ記録] を [有効にする], または [無効する] に指定できる記載を確認できます<br>　　 ※URL から、当該設定は以下に存在することが分かります</p><p>　　(1)system.applicationhost – (2)sites – (3)site – (4)logfile</p><p>　　 この場所が、上述した “セクション” に該当するとお考えください</p><ol start="2"><li>IIS マネージャーを起動後、左ペインから Web サーバーを選択して、<br>[構成エディター] を開き、セクションから system.applicationHost – sites を選択します</li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic6.png" alt="reference"></p><ol start="3"><li>[コレクション], [Count=1] と表示されている右端の […] をクリックして、<br>「コレクション エディター」を起動します</li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic7.png" alt="reference"></p><ol start="4"><li>[項目:] 欄にて、“name” が “Default Web Site” である行（これが (3)site）を選択して、<br>[プロパティ: ] 欄にて、”logFile”（これが (4)logfile）を展開します</li></ol><p>![<a href="/jpwebapps/web-apps/ConfigurationEditor/pic8.png">reference</a></p><ol start="5"><li>“enabled” の値（既定では “True”）をクリックして指定したい値に変更します</li></ol><p>　　 True: [有効にする]<br>　　 False: [無効にする]</p><ol start="6"><li>「コレクション エディター」を閉じることで、右ペインの [スクリプトの生成] が<br>　  活性化されますので [スクリプトの生成] をクリックします</li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic9.png" alt="reference"></p><ol start="7"><li><p>「スクリプト ダイアログ」から、生成したいコマンドのタブを選択します</p><p>　　 コマンドレット: ”PowerShell” タブ<br>　　 コマンド: ”コマンド ライン（AppCmd）” タブ</p></li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic10.png" alt="reference"></p><ol start="8"><li>例えばコマンド ラインの場合には、以下の様に AppCmd が出力されます</li></ol><blockquote><p>　appcmd.exe set config  -section:system.applicationHost/sites /“[name=’Default Web Site’].logFile.enabled:”False””  /commit:apphost<br>　appcmd.exe set config  -section:system.applicationHost/sites /“[name=’Default Web Site’].logFile.enabled:”True””  /commit:apphost<br>　　※ AppCmd はカレント ディレクトリを C:\Windows\System32\inetsrv に移動して実行してください</p></blockquote><ol start="9"><li>コマンドレット、コマンドのいずれの場合でも、管理者権限にて起動した PowerShell や<br>　  コマンド プロンプト上で実行して、以下の設定が変更されるかを確認します</li></ol><p>　　 “Default Web Site”<br>　　　 - [ログ記録]<br>　　　　　 - 右ペインの [有効にする], または [無効にする]</p><p>　なお、上記の appcmd コマンドを実行した後、applicationHost.config ファイル内では<br>　以下の要素が書き換わっていることを確認することが出来ます</p><h5 id="AppCmd-実行後の-applicationHost-config-内でのイメージ（上-有効にする-下-無効にする-）"><a href="#AppCmd-実行後の-applicationHost-config-内でのイメージ（上-有効にする-下-無効にする-）" class="headerlink" title="AppCmd 実行後の applicationHost.config 内でのイメージ（上: [有効にする], 下: [無効にする]）"></a>AppCmd 実行後の applicationHost.config 内でのイメージ（上: [有効にする], 下: [無効にする]）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;logFile logTargetW3C=&quot;File&quot; directory=&quot;%SystemDrive%\inetpub\logs\LogFiles&quot; enabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;logFile logTargetW3C=&quot;File&quot; directory=&quot;%SystemDrive%\inetpub\logs\LogFiles&quot; enabled=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure><ol start="10"><li>[適用] をクリックすると変更した値が反映されてしまうため、コマンドの<br>　   生成と取得のみを行いたい場合には、[キャンセル] をクリックする、または<br>　  IIS マネージャーにおいて他の画面に遷移した際に、以下のダイアログが<br>　  出力されますので、[いいえ] をクリックすることで設定の反映を防げます</li></ol><p><img src="/jpwebapps/web-apps/ConfigurationEditor/pic11.png" alt="reference"></p><p>今回は以上です。 それでは、また次回！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。&lt;br&gt; &lt;br&gt;IIS サポート チームです！&lt;/p&gt;
&lt;p&gt;[構成エディター] を使用することで、IIS マネージャー上の設定を変更する&lt;br&gt;コマンドレット（PowerShell）やコマンドを生成することが出来ます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/j</summary>
      
    
    
    
    
    <category term="Internet Information Services" scheme="https://microsoft.github.io/jpwebapps/tags/Internet-Information-Services/"/>
    
    <category term="Configuration Editor" scheme="https://microsoft.github.io/jpwebapps/tags/Configuration-Editor/"/>
    
  </entry>
  
</feed>
